(window.webpackJsonp=window.webpackJsonp||[]).push([[7],Array(63).concat([function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return b}));var a=n(2),i=n(6),o=(n(0),n(69)),r={title:"A Git introduction with no commands",slug:"../git_basics"},s={unversionedId:"20200503-git_intro/README",id:"20200503-git_intro/README",isDocsHomePage:!1,title:"A Git introduction with no commands",description:"Using Git is a mandatory skill for any software engineer in today's industry,",source:"@site/docs/20200503-git_intro/README.md",slug:"/git_basics",permalink:"/git_basics",version:"current",sidebar:"someSidebar",previous:{title:"About me",permalink:"/"},next:{title:"Static variables, static storage, static initialization, constant initialization, constinit, constexpr",permalink:"/const_constinit_constexpr_consteval"}},c=[{value:"Staging",id:"staging",children:[]},{value:"Commit definition",id:"commit-definition",children:[]},{value:"How a sequence of commits form a graph",id:"how-a-sequence-of-commits-form-a-graph",children:[]},{value:"Branches: a name and a pointer",id:"branches-a-name-and-a-pointer",children:[]},{value:"You are where your HEAD is.",id:"you-are-where-your-head-is",children:[]},{value:"A word on detached <code>HEADS</code>",id:"a-word-on-detached-heads",children:[]},{value:"Change branches often...",id:"change-branches-often",children:[]},{value:"... except when you can&#39;t",id:"-except-when-you-cant",children:[]},{value:"The graph doesn&#39;t have to be linear",id:"the-graph-doesnt-have-to-be-linear",children:[]},{value:"Deleting a branch deletes a name.",id:"deleting-a-branch-deletes-a-name",children:[{value:"Git will not let you delete some branches.",id:"git-will-not-let-you-delete-some-branches",children:[]}]},{value:"Easy merging: fast forward",id:"easy-merging-fast-forward",children:[]},{value:"Non-trivial merges",id:"non-trivial-merges",children:[{value:"Three-way merge!",id:"three-way-merge",children:[]},{value:"Rebase!",id:"rebase",children:[]},{value:"Keeping feature branches up-to-date with the main branch",id:"keeping-feature-branches-up-to-date-with-the-main-branch",children:[]}]},{value:"Remotes",id:"remotes",children:[]},{value:"Agreement on distributed systems is a hard problem",id:"agreement-on-distributed-systems-is-a-hard-problem",children:[]},{value:"Follow an origin",id:"follow-an-origin",children:[]},{value:"Origin with some interface",id:"origin-with-some-interface",children:[]}],l={rightToc:c};function b(e){var t=e.components,r=Object(i.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},l,r,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"Using Git is a mandatory skill for any software engineer in today's industry,\nbut it's surprisingly difficult to find an introduction to the mental model\nbehind Git. Most Git users repeat a set of memorized commands that work for\nsome situations, resorting to colleagues when the cheat sheet fails."),Object(o.b)("p",null,"I used to be in that camp before opening the magic box behind the command line\ninterface. Having understood Git's conceptual model, I am now able to use the\ntool more effectively than before, employing it in ways that I didn't know were\npossible. By framing a problem as an operation on the commit history graph, I\ncan easily find the Git command I need to solve it."),Object(o.b)("p",null,"With this post, I intend to go over Git's conceptual model ",Object(o.b)("em",{parentName:"p"},"without\nmentioning a single command-line operation"),'. Once the model is clear, then we\nlook at daily actions performed by developers and map those actions to Git\nconcepts. This is my attempt at "how I wish Git had been explained to me".'),Object(o.b)("h1",{id:"saving-snapshots-of-the-project"},"Saving snapshots of the project"),Object(o.b)("p",null,'At its core, a version control system is a program that keeps track of the\nstate of a repository as it evolves through time. It allows us to go back and\nforth between states, to record new states, and to inspect the "history" of the\nrepository.'),Object(o.b)("p",null,"In Git, saving a new state of the repository consists of:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"Making changes to files or adding new ones."),Object(o.b)("li",{parentName:"ol"},"Specifying which changes should be recorded by adding those changes to the\n",Object(o.b)("em",{parentName:"li"},"staging area"),"."),Object(o.b)("li",{parentName:"ol"},"Performing a ",Object(o.b)("em",{parentName:"li"},"commit")," operation.")),Object(o.b)("p",null,"For now, don't worry about what this commit operation is, we'll talk about it\nsoon."),Object(o.b)("h2",{id:"staging"},"Staging"),Object(o.b)("p",null,"The staging area consists of a set of changes that will be included by the next\ncommit operation. It partitions the repository into three categories of files:"),Object(o.b)("p",null,Object(o.b)("img",{alt:"file_partitions",src:n(119).default})),Object(o.b)("p",null,"During development, we are editing files, staging ",Object(o.b)("em",{parentName:"p"},"changes"),", and finally doing a\ncommit operation:"),Object(o.b)("p",null,Object(o.b)("img",{alt:"transitions 1",src:n(120).default})),Object(o.b)("p",null,"Nothing stops us from editing a file, staging it and editing the file again;\nthis effectively creates a new kind of file that has both staged and unstaged\nchanges. It's up to us to decide what we want the next commit to include: if\nit should include the new changes, then we have to stage them too."),Object(o.b)("p",null,Object(o.b)("img",{alt:"transitions 2",src:n(121).default})),Object(o.b)("p",null,"Git also allows us to stage ",Object(o.b)("em",{parentName:"p"},"some")," of the changes in a file, in fact the mental\nmodel is that we stage changes done to a file, not the file itself. Staging\nonly a subset of the changes done to a file is helpful in case they don't all\nlogically belong on the same commit."),Object(o.b)("p",null,Object(o.b)("img",{alt:"transitions 3",src:n(122).default})),Object(o.b)("h2",{id:"commit-definition"},"Commit definition"),Object(o.b)("p",null,"So what is a commit operation?"),Object(o.b)("p",null,"When a commit is performed, ",Object(o.b)("em",{parentName:"p"},"a snapshot of the entire repository is taken")," and\nstored into an internal data structure of Git. A commit operation creates a\ncommit object, which consists of:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"A pointer to that snapshot,"),Object(o.b)("li",{parentName:"ol"},"the author's name and email,"),Object(o.b)("li",{parentName:"ol"},"a commit message, and"),Object(o.b)("li",{parentName:"ol"},"pointer to the commit that came directly before this commit.")),Object(o.b)("p",null,"By pointer we mean a SHA-1 hash of the object; it is common to refer\nto a commit by its hash."),Object(o.b)("p",null,"Note: if any of the items above is changed, the commit hash will change too!"),Object(o.b)("p",null,Object(o.b)("img",{alt:"a commit",src:n(123).default})),Object(o.b)("p",null,'Unfortunately, the verb "commit"  and the noun "commit" are the spelled the\nsame way in English; when we use it as a verb, we mean the act of perfoming a\ncommit operation, whereas the noun refers to the commit object (or its hash).'),Object(o.b)("h2",{id:"how-a-sequence-of-commits-form-a-graph"},"How a sequence of commits form a graph"),Object(o.b)("p",null,"Because a commit stores a reference to the preceding commit, in other other\nwords, because a commit has a parent, the repository can be represented as a\ndirected acyclic graph: nodes are commits and a directed edge ",Object(o.b)("inlineCode",{parentName:"p"},"(commit2, commit1)")," indicates\nthat commit ",Object(o.b)("inlineCode",{parentName:"p"},"commit1")," is a parent of ",Object(o.b)("inlineCode",{parentName:"p"},"commit2"),"."),Object(o.b)("p",null,Object(o.b)("img",{alt:"three commits",src:n(124).default})),Object(o.b)("p",null,"For ease of representation, I'm using names for the commits in the pictures,\nbut ",Object(o.b)("inlineCode",{parentName:"p"},"commit1")," and ",Object(o.b)("inlineCode",{parentName:"p"},"commit2")," actually represent the hash of the respective\ncommits."),Object(o.b)("h2",{id:"branches-a-name-and-a-pointer"},"Branches: a name and a pointer"),Object(o.b)("p",null,"The concept of a ",Object(o.b)("em",{parentName:"p"},"branch")," is what allows us to navigate through important states\nof a repository. A branch in Git is a pair ",Object(o.b)("inlineCode",{parentName:"p"},"(name, pointer to a commit)"),"."),Object(o.b)("p",null,Object(o.b)("img",{alt:"three branches",src:n(125).default})),Object(o.b)("p",null,"In this example, we have two branches named ",Object(o.b)("inlineCode",{parentName:"p"},"feature1")," and ",Object(o.b)("inlineCode",{parentName:"p"},"master"),", both\npointing to commit ",Object(o.b)("inlineCode",{parentName:"p"},"commit1"),", and a branch named ",Object(o.b)("inlineCode",{parentName:"p"},"feature2")," pointing to\n",Object(o.b)("inlineCode",{parentName:"p"},"commit2"),"."),Object(o.b)("p",null,"Note: there is nothing special about the branch named ",Object(o.b)("inlineCode",{parentName:"p"},"master"),". When you create\na repository from scratch, you need a name for the starting branch -- ",Object(o.b)("inlineCode",{parentName:"p"},"master"),"\nis the default and few repositories bother renaming it."),Object(o.b)("h2",{id:"you-are-where-your-head-is"},"You are where your HEAD is."),Object(o.b)("p",null,"Since we're jumping around the history of the repository all the time, how do\nwe know which snapshot we're looking at? This information is tracked by a\nspecial pointer, called ",Object(o.b)("inlineCode",{parentName:"p"},"HEAD"),". Most of the time, ",Object(o.b)("inlineCode",{parentName:"p"},"HEAD")," points to a branch:"),Object(o.b)("p",null,Object(o.b)("img",{alt:"head introduction",src:n(126).default})),Object(o.b)("p",null,"In this example, we are looking at the repository as defined by branch\n",Object(o.b)("inlineCode",{parentName:"p"},"feature2"),", which points to ",Object(o.b)("inlineCode",{parentName:"p"},"commit2"),"."),Object(o.b)("p",null,"When we add a new commit, we advance the branch pointed by the ",Object(o.b)("inlineCode",{parentName:"p"},"HEAD"),":"),Object(o.b)("p",null,Object(o.b)("img",{alt:"head advancing",src:n(127).default})),Object(o.b)("h2",{id:"a-word-on-detached-heads"},"A word on detached ",Object(o.b)("inlineCode",{parentName:"h2"},"HEADS")),Object(o.b)("p",null,"What if we want to inspect snapshots that are not pointed to by any\nbranch, like ",Object(o.b)("inlineCode",{parentName:"p"},"commit2"),"? You can use its hash and force ",Object(o.b)("inlineCode",{parentName:"p"},"HEAD")," to point to it:"),Object(o.b)("p",null,Object(o.b)("img",{alt:"detached_head_state",src:n(128).default})),Object(o.b)("p",null,"You are now in what is called a ",Object(o.b)("em",{parentName:"p"},"detached  ",Object(o.b)("inlineCode",{parentName:"em"},"HEAD")," state"),", that is, ",Object(o.b)("inlineCode",{parentName:"p"},"HEAD")," is\nnot following any branches. This is not what you'll be doing 99.99% of the\ntime and, once in a detached ",Object(o.b)("inlineCode",{parentName:"p"},"HEAD")," state, you'll either create a new branch\npointing to the current snapshot, or switch to some other branch; both of those\nactions restore your ",Object(o.b)("inlineCode",{parentName:"p"},"HEAD")," to its natural state: that of tracking branches."),Object(o.b)("h2",{id:"change-branches-often"},"Change branches often..."),Object(o.b)("p",null,"Changing a branch is simple: just point your ",Object(o.b)("inlineCode",{parentName:"p"},"HEAD")," to it, and Git will\nassemble the repository as it was in the commit pointed to by that branch."),Object(o.b)("p",null,Object(o.b)("img",{alt:"changing heads",src:n(129).default})),Object(o.b)("h2",{id:"-except-when-you-cant"},"... except when you can't"),Object(o.b)("p",null,"Changing branches is a natural operation that we perform often, but it has the\npotential to overwrite non-committed changes."),Object(o.b)("p",null,"For example, suppose you have edited ",Object(o.b)("inlineCode",{parentName:"p"},"main.cpp")," ",Object(o.b)("strong",{parentName:"p"},"but not committed those\nchanges")," and suppose you attempt to change ",Object(o.b)("inlineCode",{parentName:"p"},"HEAD")," to ",Object(o.b)("inlineCode",{parentName:"p"},"other_branch"),".  However,\n",Object(o.b)("inlineCode",{parentName:"p"},"main.cpp")," is different in ",Object(o.b)("inlineCode",{parentName:"p"},"other_branch"),". What should happen to your\nnon-committed changes? Should Git discard them  and overwrite ",Object(o.b)("inlineCode",{parentName:"p"},"main.cpp")," with\nthe version in ",Object(o.b)("inlineCode",{parentName:"p"},"other_branch"),"?"),Object(o.b)("p",null,"Git follows a principle that it will ",Object(o.b)("strong",{parentName:"p"},"never"),' allow you to lose changes by accident,\nunless you are explicit about it by using dangerous keywords like "force" or\n"hard".'),Object(o.b)("p",null,"In the example above, unless Git can ",Object(o.b)("em",{parentName:"p"},"cleanly")," and ",Object(o.b)("em",{parentName:"p"},"unambiguously")," apply the\nnon-committed changes on top of the target branch, it will NOT let you change\nbranches. In particular, you should be able to move back and forth between two\nbranches without any loss of information; if that's not possible, Git will not\nlet you change branches."),Object(o.b)("p",null,"Merely staging the changes wouldn't be enough either. In other words: commit,\ncommit, commit, commit. Don't be afraid of committing, it is the most powerful\ntool in your toolbox."),Object(o.b)("h2",{id:"the-graph-doesnt-have-to-be-linear"},"The graph doesn't have to be linear"),Object(o.b)("p",null,'So far, our graph has always been a "straight line". However, what happens if\nwe add a new commit to ',Object(o.b)("inlineCode",{parentName:"p"},"feature1")," in the example shown previously? The graph\nbecomes more interesting:"),Object(o.b)("p",null,Object(o.b)("img",{alt:"non linear history",src:n(130).default})),Object(o.b)("p",null,"Note that, because our head was pointing to the ",Object(o.b)("inlineCode",{parentName:"p"},"feature1")," branch, the next\ncommit advanced that branch."),Object(o.b)("h2",{id:"deleting-a-branch-deletes-a-name"},"Deleting a branch deletes a name."),Object(o.b)("p",null,"Because a branch is just a pointer, deleting it is a quick operation: just\ndelete the pointer. However..."),Object(o.b)("h3",{id:"git-will-not-let-you-delete-some-branches"},"Git will not let you delete some branches."),Object(o.b)("p",null,"What if deleting a branch would cause loss of information?"),Object(o.b)("p",null,"The canonical way to navigate between states of your repository is by\nchanging your HEAD so that it points to different branches, and that is done\nthrough branch names; Git doesn't expect you to memorize hashes."),Object(o.b)("p",null,"Consider this example:"),Object(o.b)("p",null,Object(o.b)("img",{alt:"cant delete branch",src:n(131).default})),Object(o.b)("p",null,"If we delete the branch ",Object(o.b)("inlineCode",{parentName:"p"},"feature2"),", the commits in red would be lost forever:\nthere is no branch that includes those commits, i.e. there is no way to put\nyour repository in a state containing those commits",Object(o.b)("sup",{parentName:"p",id:"fnref-1"},Object(o.b)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1")),". The only way to\ninspect those commits would be if you memorized their hashes and moved into a\ndetached head state."),Object(o.b)("p",null,"As such, Git will not let you delete that branch unless you force it to."),Object(o.b)("h1",{id:"merging-branches"},"Merging branches"),Object(o.b)("p",null,"We've seen what branches are and how they relate to commits. The next building\nblock to be examined is how to merge work from one branch into another. There\nare many different ways to accomplish this, and the choice depends on what\nyou want the final commit history to look like."),Object(o.b)("h2",{id:"easy-merging-fast-forward"},"Easy merging: fast forward"),Object(o.b)("p",null,"Let's consider the scenario we had before:"),Object(o.b)("p",null,Object(o.b)("img",{alt:"ready to merge",src:n(132).default})),Object(o.b)("p",null,"Suppose the work from the ",Object(o.b)("inlineCode",{parentName:"p"},"feature1")," branch has been tested and is ready to be\nmerged back into ",Object(o.b)("inlineCode",{parentName:"p"},"master"),". To emphasize: we want to merge ",Object(o.b)("inlineCode",{parentName:"p"},"feature1")," into\n",Object(o.b)("inlineCode",{parentName:"p"},"master"),", not the other way around (more on this later). "),Object(o.b)("p",null,"Well, lucky you, nobody has committed into master since the work on ",Object(o.b)("inlineCode",{parentName:"p"},"feature1"),"\nstarted! Because ",Object(o.b)("strong",{parentName:"p"},"all commits in ",Object(o.b)("inlineCode",{parentName:"strong"},"master")," are also in ",Object(o.b)("inlineCode",{parentName:"strong"},"feature1")),", Git can\nsimply move the ",Object(o.b)("inlineCode",{parentName:"p"},"master")," pointer forward, a method known as a ",Object(o.b)("em",{parentName:"p"},"fast forward"),":"),Object(o.b)("p",null,Object(o.b)("img",{alt:"afer merge",src:n(133).default})),Object(o.b)("p",null,"This method is always free of conflicts, that is, it will never require manual\nintervention to resolve edits made in the same file on the two branches being\nmerged."),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"feature1")," branch is now irrelevant and can be deleted:"),Object(o.b)("p",null,Object(o.b)("img",{alt:"afer merge branch deleted",src:n(134).default})),Object(o.b)("h2",{id:"non-trivial-merges"},"Non-trivial merges"),Object(o.b)("p",null,"When many developers are working on the same repository, chances are Git won't\nalways be able to fast-forward. Suppose the ",Object(o.b)("inlineCode",{parentName:"p"},"feature2")," branch from above is\nready to be merged back into master, what will happen?"),Object(o.b)("h3",{id:"three-way-merge"},"Three-way merge!"),Object(o.b)("p",null,"When fast forwards are not possible, Git will identify three commits to help it\nperform the merge:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"The commit pointed to by the destination branch."),Object(o.b)("li",{parentName:"ol"},"The commit pointed to by the source branch."),Object(o.b)("li",{parentName:"ol"},"The commit that is the lowest common ancestor of 1 and 2.")),Object(o.b)("p",null,"Using our previous example, the commits are as follows:"),Object(o.b)("p",null,Object(o.b)("img",{alt:"merge_commit_points",src:n(135).default})),Object(o.b)("p",null,"Using those commits, Git will now merge the two branches, identify conflicting\nchanges and create a new commit representing the merge:"),Object(o.b)("p",null,Object(o.b)("img",{alt:"merge_commit",src:n(136).default})),Object(o.b)("p",null,"If any conflicting changes are found, Git will ask you to resolve them before\nthe merge commit is created."),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"feature2")," branch can now be deleted."),Object(o.b)("h3",{id:"rebase"},"Rebase!"),Object(o.b)("p",null,"A lot of projects frown upon complicated graphs for their main development\nbranches, as such, they forbid three-way merges. To maintain a clean and linear\nhistory, a different procedure is needed."),Object(o.b)("p",null,"Let's pretend we never did the three-way merge with ",Object(o.b)("inlineCode",{parentName:"p"},"feature2"),":"),Object(o.b)("p",null,Object(o.b)("img",{alt:"before rebase",src:n(137).default})),Object(o.b)("p",null,"Instead of a three-way merge, we can re-apply commits from ",Object(o.b)("inlineCode",{parentName:"p"},"feature2")," on top of\n",Object(o.b)("inlineCode",{parentName:"p"},"master"),", this is known as a rebase of ",Object(o.b)("inlineCode",{parentName:"p"},"feature2")," on top of ",Object(o.b)("inlineCode",{parentName:"p"},"master"),"."),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Start with our ",Object(o.b)("inlineCode",{parentName:"p"},"HEAD")," on the source branch (",Object(o.b)("inlineCode",{parentName:"p"},"feature2"),").")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Git rewinds ",Object(o.b)("inlineCode",{parentName:"p"},"HEAD")," to the lowest common ancestor of the two branches.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Git forwards ",Object(o.b)("inlineCode",{parentName:"p"},"HEAD")," along the path of the target branch (",Object(o.b)("inlineCode",{parentName:"p"},"master"),")."),Object(o.b)("p",{parentName:"li"},Object(o.b)("img",{alt:"mid_rebase",src:n(138).default}))),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Git replays the commits of ",Object(o.b)("inlineCode",{parentName:"p"},"feature2"),"."),Object(o.b)("p",{parentName:"li"},Object(o.b)("img",{alt:"rebase_finished",src:n(139).default})))),Object(o.b)("p",null,"If any commits can't be applied cleanly, Git asks for your intervention before continuing."),Object(o.b)("p",null,"Note: the new commits are different from the original ones and they will have\ndifferent hashes. Why?",Object(o.b)("sup",{parentName:"p",id:"fnref-2"},Object(o.b)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2"))),Object(o.b)("p",null,"Now, if you switch HEAD to ",Object(o.b)("inlineCode",{parentName:"p"},"master")," and try to merge with ",Object(o.b)("inlineCode",{parentName:"p"},"feature2"),", a simple\nfast forward will do!"),Object(o.b)("h3",{id:"keeping-feature-branches-up-to-date-with-the-main-branch"},"Keeping feature branches up-to-date with the main branch"),Object(o.b)("p",null,"When developing a big feature in a separate branch, it's wise to ensure our\ncode is up-to-date with the main branch of the project, otherwise we run the\nrisk of working on top of a stale version of the code base."),Object(o.b)("p",null,"One way to accomplish this is by frequently merging the main branch into the\nfeature branch:"),Object(o.b)("p",null,Object(o.b)("img",{alt:"frequent_merges",src:n(140).default})),Object(o.b)("p",null,"If your project disallows three way merges, you would frequently\nrebase the feature branch on top of the main branch:"),Object(o.b)("p",null,Object(o.b)("img",{alt:"frequent_rebases",src:n(141).default})),Object(o.b)("h1",{id:"distributed-git"},"Distributed Git"),Object(o.b)("p",null,"So far, everything we've covered assumes the entirety of development is\nperformed locally, that is, there are no copies of the repository outside our\nmachine. There are no pesky coworkers, no remote servers, nothing!"),Object(o.b)("p",null,"However, that's not how modern development is done. So how does Git handle\nmultiple developers?"),Object(o.b)("h2",{id:"remotes"},"Remotes"),Object(o.b)("p",null,"A ",Object(o.b)("em",{parentName:"p"},"remote")," is just another copy of the same repository located elsewhere.\nGit needs to know where and how to find it through an address and protocol:\nssh, https, file system path, etc."),Object(o.b)("p",null,"Suppose Alice and Bob both have a copy of the same repository in their own\nmachines:"),Object(o.b)("p",null,Object(o.b)("img",{alt:"alice_and_bob",src:n(142).default})),Object(o.b)("p",null,"Now suppose Alice and Bob want to collaborate, thus they need the ability to\nsee what each other is up to. Alice will add a ",Object(o.b)("em",{parentName:"p"},"remote")," called ",Object(o.b)("inlineCode",{parentName:"p"},"remote_bob")," and\nBob will add a ",Object(o.b)("em",{parentName:"p"},"remote")," called ",Object(o.b)("inlineCode",{parentName:"p"},"remote_alice"),"."),Object(o.b)("p",null,Object(o.b)("img",{alt:"alice_and_bob_with_remotes",src:n(143).default})),Object(o.b)("p",null,"Both will then ",Object(o.b)("em",{parentName:"p"},"fetch")," updates from their remotes, resulting in the following\ntrees:"),Object(o.b)("p",null,Object(o.b)("img",{alt:"alice_and_bob_after_fetch",src:n(144).default})),Object(o.b)("h2",{id:"agreement-on-distributed-systems-is-a-hard-problem"},"Agreement on distributed systems is a hard problem"),Object(o.b)("p",null,"Because the copies are independent of each other, branches may evolve differently\nin each remote. For instance, Alice and Bob might make different, independent commits\nin their master branches:"),Object(o.b)("p",null,Object(o.b)("img",{alt:"masters_diverged",src:n(145).default})),Object(o.b)("p",null,"Which version of master should be accepted as correct? The situation can get a\nlot worse if you have many developers working at the same time. How are all\nthese developers supposed to agree on what the correct version of a branch\nshould be?"),Object(o.b)("h2",{id:"follow-an-origin"},"Follow an origin"),Object(o.b)("p",null,"The typical way to solve this problem is by electing a ",Object(o.b)("em",{parentName:"p"},"remote")," to be the\ncorrect copy of the repository, and letting developers try to influence it.\nUsually, this remote is called ",Object(o.b)("inlineCode",{parentName:"p"},"origin"),"."),Object(o.b)("p",null,"Consider the situation we had before, where Alice and Bob had diverged on what\nmaster should look like. Instead of interacting with each other's repository\ndirectly, they only interact with ",Object(o.b)("inlineCode",{parentName:"p"},"origin"),":"),Object(o.b)("p",null,Object(o.b)("img",{alt:"enter_the_origin",src:n(146).default})),Object(o.b)("p",null,"(I'm omitting ",Object(o.b)("inlineCode",{parentName:"p"},"HEAD")," here to keep the diagram manageable.)"),Object(o.b)("p",null,"To publish their own versions of ",Object(o.b)("inlineCode",{parentName:"p"},"master")," to ",Object(o.b)("inlineCode",{parentName:"p"},"origin/master"),", Alice and Bob will\nattempt to perform a ",Object(o.b)("em",{parentName:"p"},"push")," operation into their ",Object(o.b)("inlineCode",{parentName:"p"},"origin")," remote. Let's assume\nthat Alice performs her ",Object(o.b)("em",{parentName:"p"},"push")," first, resulting in the following scenario:"),Object(o.b)("p",null,Object(o.b)("img",{alt:"alice_won",src:n(147).default})),Object(o.b)("p",null,"Notice how Bob doesn't yet know that ",Object(o.b)("inlineCode",{parentName:"p"},"origin")," has accepted Alice's update to\nmaster. When Bob tries to push his ",Object(o.b)("inlineCode",{parentName:"p"},"master")," into ",Object(o.b)("inlineCode",{parentName:"p"},"origin/master"),", Git will tell\nhim: \"I can't do this, because your ",Object(o.b)("inlineCode",{parentName:"p"},"origin/master")," is not what ",Object(o.b)("inlineCode",{parentName:"p"},"origin")," says\nit should be. Do a ",Object(o.b)("em",{parentName:"p"},"fetch"),' first!"'),Object(o.b)("p",null,"Once Bob fetches ",Object(o.b)("inlineCode",{parentName:"p"},"origin"),", this is what he sees:"),Object(o.b)("p",null,Object(o.b)("img",{alt:"bob_fetches",src:n(148).default})),Object(o.b)("p",null,"Then Bob can either rebase ",Object(o.b)("inlineCode",{parentName:"p"},"master")," on top of ",Object(o.b)("inlineCode",{parentName:"p"},"origin/master")," or merge\n",Object(o.b)("inlineCode",{parentName:"p"},"origin/master")," into ",Object(o.b)("inlineCode",{parentName:"p"},"master"),". Now Bob is ready to ",Object(o.b)("em",{parentName:"p"},"push")," ",Object(o.b)("inlineCode",{parentName:"p"},"master")," to\n",Object(o.b)("inlineCode",{parentName:"p"},"origin/master"),"."),Object(o.b)("p",null,"Here's what the final result would look like if Bob had used the merge option:"),Object(o.b)("p",null,Object(o.b)("img",{alt:"bob_pushes",src:n(149).default})),Object(o.b)("h2",{id:"origin-with-some-interface"},"Origin with some interface"),Object(o.b)("p",null,"In the previous example, ",Object(o.b)("inlineCode",{parentName:"p"},"origin")," could only be changed by trying to ",Object(o.b)("inlineCode",{parentName:"p"},"push"),"\nupdates to it. However, all pushes are rejected unless we have\nthe exactly same view of the branch being pushed to as ",Object(o.b)("inlineCode",{parentName:"p"},"origin")," does."),Object(o.b)("p",null,"To fix this problem, it might be desirable to have ",Object(o.b)("inlineCode",{parentName:"p"},"origin")," itself run commands\non its copy of the repository and let downstream users -- like Alice and Bob --\nget updates by fetching; this is what services that host a repository typically\nprovide."),Object(o.b)("p",null,"For instance, Alice might create a new branch, do some work, commit, and push\nthis new branch to ",Object(o.b)("inlineCode",{parentName:"p"},"origin"),". This push will always work without issues, because\nshe's the only one working on it (barring any unlucky events where Bob created\na branch with the same name)"),Object(o.b)("p",null,Object(o.b)("img",{alt:"alice_origin_feature",src:n(150).default})),Object(o.b)("p",null,"Alice can then go into the interface provided by ",Object(o.b)("inlineCode",{parentName:"p"},"origin"),' - likely a webpage -\nclick a "create merge request" button, specifying ',Object(o.b)("inlineCode",{parentName:"p"},"feature_alice")," as the source\nbranch and ",Object(o.b)("inlineCode",{parentName:"p"},"master")," as the destination branch.  This will have the effect\nof ",Object(o.b)("inlineCode",{parentName:"p"},"origin")," performing the merge on its side."),Object(o.b)("p",null,Object(o.b)("img",{alt:"alice_origin_feature_merged",src:n(151).default})),Object(o.b)("p",null,"Note that Alice will not see the merge on her copy of the repository until she\nperforms a fetch."),Object(o.b)("p",null,"If the merge can't be performed due to conflicts, the interface will let Alice\nknow."),Object(o.b)("h1",{id:"conclusion"},"Conclusion"),Object(o.b)("p",null,"With the mental model clear, you'll have a much easier time with the command\nline interface, as the terminology used in this article reflects what Git uses\nfor its commands and its manual. The next step is to start over, and match\neach operation we discussed to its equivalent command. I've linked some\nresources for further reading below."),Object(o.b)("p",null,"Feel free to send me a message on Twitter if you feel like something isn't clear!"),Object(o.b)("h1",{id:"further-reading"},"Further reading"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Git has its own book called ",Object(o.b)("a",{parentName:"p",href:"https://git-scm.com/book/en/v2"},"Pro Git")," and it's free! It is by far the best\nresource I found while learning.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"If you're wondering how to use branches to effectively manage a project, I\nrecommend reading the following articles: ",Object(o.b)("a",{parentName:"p",href:"https://nvie.com/posts/a-successful-git-branching-model/"},"A successful Git branching model"),"\nand the ",Object(o.b)("a",{parentName:"p",href:"https://guides.github.com/introduction/flow/"},"Github guide"),"."))),Object(o.b)("div",{className:"footnotes"},Object(o.b)("hr",{parentName:"div"}),Object(o.b)("ol",{parentName:"div"},Object(o.b)("li",{parentName:"ol",id:"fn-1"},"In fact, Git would permanently delete all contents\nassociated with those commits next time it tries to cleanup its internal data\nstructures.",Object(o.b)("a",{parentName:"li",href:"#fnref-1",className:"footnote-backref"},"\u21a9")),Object(o.b)("li",{parentName:"ol",id:"fn-2"},"The new commits have different\nparent commits, and if you had to solve any conflicts during the rebase, each\nintermediate snapshot will be different.",Object(o.b)("a",{parentName:"li",href:"#fnref-2",className:"footnote-backref"},"\u21a9")))))}b.isMDXComponent=!0},,,,,,function(e,t,n){"use strict";n.d(t,"a",(function(){return m})),n.d(t,"b",(function(){return p}));var a=n(0),i=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=i.a.createContext({}),b=function(e){var t=i.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},m=function(e){var t=b(e.components);return i.a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},d=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,r=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),m=b(n),d=a,p=m["".concat(r,".").concat(d)]||m[d]||h[d]||o;return n?i.a.createElement(p,s(s({ref:t},l),{},{components:n})):i.a.createElement(p,s({ref:t},l))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var l=2;l<o;l++)r[l]=n[l];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/three_categories-db878eaf825e5e18c5f564518ff9e87a.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/transitions1-ef284cdc831e6c0de35c93c42b471527.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/transitions2-8862a6d1071e356df74adf8ed53585fb.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/transitions3-b0382367031cc483bab7bdbdc93773ba.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/commit-5c817282f2f1511b2e0070419a961148.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/three_commits-858c0080e18e134b2e4f5f27525107a2.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/three_branches-dc3714b060be01a86e46abf5dc09127d.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/head_intro-1b595d6e919931619c7b1db0d4792342.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/head_advanced-1455b15f9af0f535d3944df952741ad8.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/detached_head_state-11acddcb77a1432f04989824269f0b36.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/change_head-5d923c107fe4158dcfcd7762337dc6ef.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/non_straight_line-e210935e5b6845249a120b4df64754c3.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/cant_delete_branch-8824885b30b0e4af6f052706cee219f0.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/ready_to_merge-78067d01ea363a32c511eb104923f74b.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/after_merge-3a157cae3dcc6657a28ddc4fec004ab6.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/after_merge_branch_deleted-a84cdcb96633474dea02d6dae5e63215.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/merge_commit_points-5128382ba2be3a94949ba402cee9f694.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/merge_commit-375e360bf35907aa7c421edd01d8d148.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/before_rebase-63a8fb87e2ad93af7e2be68c6b069fd9.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/mid_rebase-43318f91160a5456b80856c0cc07642a.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/rebase_finished-0854db9c182ccf9949981dc4062a6e68.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/frequent_merges-b693273cc9df2555cafacd03c723e64c.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/frequent_rebases-2671d59474834f7dcc8e570a250bb164.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/alice_and_bob-24d47c4b7465a882efa4a3a2301d211f.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/alice_and_bob_with_remotes-d4c0f9cad880c1cb3d18ee7a58fca396.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/alice_and_bob_after_fetch-a00eb185e41cdea9749635c6943e2f59.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/masters_diverged-76f18943cd5edec13acc21c8d0ce88c4.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/enter_the_origin-fe53c8238eeb466d8cad237b509e7799.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/alice_won-4de42531044ec04154296e63164a7ab6.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/bob_fetches-f285439d94f5684c3f5e54e6b2f00499.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/bob_pushes-b49af58ce5138e5cb658769c6d8f3dc9.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/alice_origin_feature-66c19447bc2e9ea30ff9f9655ca45c0d.svg"},function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/alice_origin_feature_merged-07bcb7a42b5ceaa6ede35d8431fa9a52.svg"}])]);