(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{66:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return c}));var i=n(2),a=(n(0),n(69));const o={title:"Topological sorting - ACM-ICPC"},l={unversionedId:"20191117-improve_spam/README",id:"20191117-improve_spam/README",isDocsHomePage:!1,title:"Topological sorting - ACM-ICPC",description:"The [2019 ACM-ICPC Latin",source:"@site/docs/20191117-improve_spam/README.md",slug:"/20191117-improve_spam/README",permalink:"/20191117-improve_spam/README",version:"current",sidebar:"someSidebar",previous:{title:"Build system basics",permalink:"/20200127-build_systems1/README"}},s=[{value:"Prerequisites",id:"prerequisites",children:[]},{value:"Improve spam !",id:"improve-spam-",children:[]},{value:"Problem statement",id:"problem-statement",children:[]},{value:"A suitable abstraction",id:"a-suitable-abstraction",children:[]},{value:"An example",id:"an-example",children:[]},{value:"Infinite emails?",id:"infinite-emails",children:[]},{value:"The naive solution",id:"the-naive-solution",children:[]},{value:"A better solution",id:"a-better-solution",children:[]},{value:"Topological sorting",id:"topological-sorting",children:[]},{value:"Computing the solution",id:"computing-the-solution",children:[]},{value:"Conclusion",id:"conclusion",children:[]},{value:"Complete solution",id:"complete-solution",children:[]}],r={rightToc:s};function c({components:e,...t}){return Object(a.b)("wrapper",Object(i.a)({},r,t,{components:e,mdxType:"MDXLayout"}),Object(a.b)("p",null,"The ",Object(a.b)("a",Object(i.a)({parentName:"p"},{href:"http://cfrp.azurewebsites.net/blog/entry/71296"}),"2019 ACM-ICPC Latin\nAmerican")," contest took place\nthis November and it is a great source of cleverly designed algorithm problems.\nThis contest is not to be taken lightly; the problems are challenging and there\nis no shame in admiting that I can solve very few of them on my own."),Object(a.b)("p",null,"That said, I will give them a try, starting with the (arguably) easiest problem\nof the contest."),Object(a.b)("h2",{id:"prerequisites"},"Prerequisites"),Object(a.b)("p",null,"This problem is about graphs, depth first search, topological sorting and\nbasic dynamic programming."),Object(a.b)("h2",{id:"improve-spam-"},"Improve spam !"),Object(a.b)("p",null,"The full problem description can be found on ",Object(a.b)("a",Object(i.a)({parentName:"p"},{href:"https://codeforces.com/gym/102428/attachments/download/9820/statements-en.pdf"}),"page 14 of the contest\nhandout"),".\nLet's read together an abridged version of the problem statement:"),Object(a.b)("h2",{id:"problem-statement"},"Problem statement"),Object(a.b)("p",null,"We're told that an email server processes emails with the following properties:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"An email address either refers to a mailing list or to a client."),Object(a.b)("li",{parentName:"ul"},"A mailing list ",Object(a.b)("inlineCode",{parentName:"li"},"L")," is defined by a list of email addresses: ",Object(a.b)("inlineCode",{parentName:"li"},"L(1), L(2), ..."),"."),Object(a.b)("li",{parentName:"ul"},"When an email is sent to a mailing list ",Object(a.b)("inlineCode",{parentName:"li"},"L"),", the server processes each email address\n",Object(a.b)("inlineCode",{parentName:"li"},"L(i)")," contained in the list:",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"If ",Object(a.b)("inlineCode",{parentName:"li"},"L(i)")," is a client, an email is sent to ",Object(a.b)("inlineCode",{parentName:"li"},"L(i)"),"."),Object(a.b)("li",{parentName:"ul"},"If ",Object(a.b)("inlineCode",{parentName:"li"},"L(i)")," is a mailing list, the server processes each email in ",Object(a.b)("inlineCode",{parentName:"li"},"L(i)"),".")))),Object(a.b)("p",null,"Given a server configuration, i.e. a list of emails plus a description of\nmailing lists and client emails, and given that an email is sent to address\n",Object(a.b)("inlineCode",{parentName:"p"},"Addr"),", we're tasked with computing:"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"The number of emails that are sent to clients."),Object(a.b)("li",{parentName:"ol"},"The number unique clients that receive an email.")),Object(a.b)("h2",{id:"a-suitable-abstraction"},"A suitable abstraction"),Object(a.b)("p",null,"The problem description lends itself very nicely to a directed graph\nrepresentation:"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},Object(a.b)("p",{parentName:"li"},"Vertices are email addresses (Lists and Clients).")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("p",{parentName:"li"},"Edges are always of the form ",Object(a.b)("inlineCode",{parentName:"p"},"List x -> Email y"),", denoting the fact that\n",Object(a.b)("inlineCode",{parentName:"p"},"List x")," contains ",Object(a.b)("inlineCode",{parentName:"p"},"Email y"),"."))),Object(a.b)("p",null,"Note that the source node of an edge is always a list address; put differently,\nvertices corresponding to client addresses are always leaves in this graph."),Object(a.b)("h2",{id:"an-example"},"An example"),Object(a.b)("p",null,"Consider the following scenario:"),Object(a.b)("p",null,Object(a.b)("img",{alt:"example 1",src:n(91).default})),Object(a.b)("p",null,"If we send an email to ",Object(a.b)("inlineCode",{parentName:"p"},"List 1"),":"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"Client 5")," gets two emails:",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"One from the path ",Object(a.b)("inlineCode",{parentName:"li"},"List 1 -> List 2 -> Client 5 "),"."),Object(a.b)("li",{parentName:"ul"},"One from the path ",Object(a.b)("inlineCode",{parentName:"li"},"List 1 -> List 3 -> List 2 -> Client 5"),"."))),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"Client 4")," gets three emails:",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"One from the path ",Object(a.b)("inlineCode",{parentName:"li"},"List 1 -> List 2-> Client 4"),"."),Object(a.b)("li",{parentName:"ul"},"One from the path ",Object(a.b)("inlineCode",{parentName:"li"},"List 1 -> List 3 -> List 2 -> Client 4"),"."),Object(a.b)("li",{parentName:"ul"},"One from the path ",Object(a.b)("inlineCode",{parentName:"li"},"List 1 -> List 3 -> Client 4"),".")))),Object(a.b)("p",null,"In this example, the answer would be:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"5 emails are sent to clients."),Object(a.b)("li",{parentName:"ul"},"2 unique clients receive emails.")),Object(a.b)("h2",{id:"infinite-emails"},"Infinite emails?"),Object(a.b)("p",null,"You might be wondering:"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"What if ",Object(a.b)("inlineCode",{parentName:"p"},"List 1")," sends an email to ",Object(a.b)("inlineCode",{parentName:"p"},"List 2"),", and ",Object(a.b)("inlineCode",{parentName:"p"},"List 2"),"\nsends an email to ",Object(a.b)("inlineCode",{parentName:"p"},"List 1"),"? That will cause an infinite number of emails to be\nsent!")),Object(a.b)("p",null,"In other words, what if there is a cycle in the graph?"),Object(a.b)("p",null,"The problem statement contains the following:"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"[...]"," only when a mailing list is created it can be added to any number of\nexisting mailing lists")),Object(a.b)("p",null,"This is a hint to the fact that it is impossible to have a cycle in the graph\ndefined by the mailing lists! Convince yourself of this fact before proceeding,\nor better yet, prove it:"),Object(a.b)("p",null,"Suppose there is a cycle ",Object(a.b)("inlineCode",{parentName:"p"},"List 1 -> List 2 -> List 1"),":"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"The edge ",Object(a.b)("inlineCode",{parentName:"li"},"List 1 -> List 2")," implies that ",Object(a.b)("inlineCode",{parentName:"li"},"List 1")," was created after ",Object(a.b)("inlineCode",{parentName:"li"},"List 2"),"."),Object(a.b)("li",{parentName:"ol"},"The edge ",Object(a.b)("inlineCode",{parentName:"li"},"List 2 -> List 1")," implies that ",Object(a.b)("inlineCode",{parentName:"li"},"List 2")," was created after ",Object(a.b)("inlineCode",{parentName:"li"},"List 1"),".")),Object(a.b)("p",null,"This forms a contradiction, so the cycle cannot exist. With induction on the\ncycle length, you can generalize this proof."),Object(a.b)("p",null,"The conclusion: we are working on a Directed Acyclic Graph (DAG)."),Object(a.b)("h2",{id:"the-naive-solution"},"The naive solution"),Object(a.b)("p",null,"Simulate the whole email-sending process: traverse the graph, starting from\naddress ",Object(a.b)("inlineCode",{parentName:"p"},"Addr"),", visiting all adjacent nodes to the node being visited.\nWhenever we visit a vertex corresponding to a client address, we increment a\ncounter of emails sent."),Object(a.b)("p",null,"Note that we might visit some nodes multiple times, as the previous example\nshows. Howeveer, our traversal is guaranteed to finish because the graph is\nacyclic."),Object(a.b)("p",null,"How efficient is this solution? The number of operations is linear in the\nnumber of times vertices are visited. Note: it is NOT linear in the number of\nvertices or edges in the graph, but on the number of times we visit vertices."),Object(a.b)("p",null,"The problem statement is trying to tell us that this approach is bound to\nfail:"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"}," Because  these  numbers  can  be  very  large,  output  the  remainder  of\ndividing them by 10^9 + 7.")),Object(a.b)("p",null,"In other words, the number of times we visit vertices is so big that it doesn't\nfit on a 32 bit integer. Can you come up with some graphs that showcase how\nspammy those emails can be?"),Object(a.b)("p",null,"Our naive solution is bound to be extremely slow and will receive a Time Limit\nExceeded answer from the contest judge."),Object(a.b)("h2",{id:"a-better-solution"},"A better solution"),Object(a.b)("p",null,"Notational convenience: ",Object(a.b)("inlineCode",{parentName:"p"},"total(Address x)")," denotes the total number of emails\nsent to clients if we send an email to ",Object(a.b)("inlineCode",{parentName:"p"},"Address x"),"."),Object(a.b)("p",null,"We're trying to compute ",Object(a.b)("inlineCode",{parentName:"p"},"total(Addr)"),". If we know this value for all\nsuccessors of ",Object(a.b)("inlineCode",{parentName:"p"},"Addr")," in the graph, then ",Object(a.b)("inlineCode",{parentName:"p"},"total(Addr)")," is simply the sum of\nall those values."),Object(a.b)("p",null,"Let's consider our previous example, where we're trying to compute the answer\nwhen ",Object(a.b)("inlineCode",{parentName:"p"},"List 1")," gets the initial email:"),Object(a.b)("p",null,Object(a.b)("img",{alt:"example 1",src:n(91).default})),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},Object(a.b)("inlineCode",{parentName:"li"},"total(Client 5) = 1"),", sending an email to a client only causes one client\nto receive an email."),Object(a.b)("li",{parentName:"ol"},Object(a.b)("inlineCode",{parentName:"li"},"total(Client 4) = 1"),", similarly.")),Object(a.b)("p",null,"We can now compute ",Object(a.b)("inlineCode",{parentName:"p"},"total(List 2)"),":"),Object(a.b)("ol",{start:3},Object(a.b)("li",{parentName:"ol"},Object(a.b)("inlineCode",{parentName:"li"},"total(List 2) = total(Client 5) + total(Client 4) = 1 + 1 = 2"),".")),Object(a.b)("p",null,"Similarly for ",Object(a.b)("inlineCode",{parentName:"p"},"total(List 3)"),":"),Object(a.b)("ol",{start:4},Object(a.b)("li",{parentName:"ol"},Object(a.b)("inlineCode",{parentName:"li"},"total(List 3) = total(List 2) + total(Client 4) = 2 + 1 = 3"),".")),Object(a.b)("p",null,"Similarly for ",Object(a.b)("inlineCode",{parentName:"p"},"total(List 1)"),":"),Object(a.b)("ol",{start:5},Object(a.b)("li",{parentName:"ol"},Object(a.b)("inlineCode",{parentName:"li"},"total(List 1) = total(List 2) + total(List 3) = 2 + 3 = 5"),".")),Object(a.b)("p",null,"And that's the answer we are looking for! If we have an array of vertices in\nsome apropriate order, what we are doing above is a simple case of dynamic\nprogramming."),Object(a.b)("p",null,"How do we obtain this apropriate order? The key is to exploit properties of\nDAGs; in particular, we want to visit only nodes whose successors have all been\nvisited. This is known as a ",Object(a.b)("a",Object(i.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Topological_sorting"}),"topological order")," and it is guaranteed to exist\nfor DAGs",Object(a.b)("sup",Object(i.a)({parentName:"p"},{id:"fnref-1"}),Object(a.b)("a",Object(i.a)({parentName:"sup"},{href:"#fn-1",className:"footnote-ref"}),"1")),"."),Object(a.b)("h2",{id:"topological-sorting"},"Topological sorting"),Object(a.b)("p",null,"One way to obtain a topological order is with a Depth First Search.\nHere's a C++ implementation",Object(a.b)("sup",Object(i.a)({parentName:"p"},{id:"fnref-2"}),Object(a.b)("a",Object(i.a)({parentName:"sup"},{href:"#fn-2",className:"footnote-ref"}),"2")),":"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-cpp"}),"void compute_topological_order() {\n  visited = std::vector<bool>(num_addresses + 1, false);\n  dfs(1);\n}\n")),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-cpp"}),"void dfs(int visiting) {\n  visited[visiting] = true;\n\n  for (auto next : successor_vertices[visiting])\n    if (!visited[next])\n      dfs(next);\n  topologic_order.push_back(visiting);\n}\n")),Object(a.b)("p",null,"This captures the idea described previously: visit all successors of a node\nfirst, then add the node itself to the topological order."),Object(a.b)("h2",{id:"computing-the-solution"},"Computing the solution"),Object(a.b)("p",null,"The number of spammy emails can be computed as follows:"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-cpp"}),"auto num_emails = std::vector<uint64_t>(num_addresses + 1, 0);\n\nfor (auto node : topologic_order) {\n  if (is_client_email(node))\n    num_emails[node] = 1;\n  else {\n    num_emails[node] = std::accumulate(\n        std::begin(successor_vertices[node]),\n        std::end(successor_vertices[node]),\n        uint64_t{0}, // Initial value\n        [&](auto sum, auto next) {\n          return (sum + num_emails[next]) % 1000000007;\n        });\n  }\n}\n\nspam_emails = num_emails[1];\n")),Object(a.b)("h2",{id:"conclusion"},"Conclusion"),Object(a.b)("p",null,"This was the easiest problem of the contest. I must admit it took me roughly 3\nhours to come up with the final, correct implementation. When you consider the\nfact that the contest lasts five hours and contains 13 problems, most of which\nare harder than this, an inevitable conclusion comes to mind: those competitors\nare really good."),Object(a.b)("p",null,"Two important mistakes I made:"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"I fell for the trap of the naive solution. Doing a few sketches in paper\nwould have been enough to prove that this was bound to fail. Also, pay\nattention to the problem statement, it's always full of hints about the\nsolution."),Object(a.b)("li",{parentName:"ol"},"I was trying to be clever and avoid a recursive implementation, doing an\niterative implementation of DFS while calculating the number of emails sent at\nthe same time. This was a mistake - simplicity first, always.")),Object(a.b)("p",null,"It's always humbling to face problems from this contest, as it reminds you of\nhow little you know and how much better you can get."),Object(a.b)("h2",{id:"complete-solution"},"Complete solution"),Object(a.b)("p",null,"This is the solution that I ",Object(a.b)("a",Object(i.a)({parentName:"p"},{href:"https://codeforces.com/gym/102428/problem/I"}),"submitted on\nCodeforces"),":"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-cpp"}),'#include <algorithm>\n#include <cstdint>\n#include <iostream>\n#include <iterator>\n#include <numeric>\n#include <vector>\n\nstruct Solver {\n\n  Solver() {\n    read_input();\n    compute_topological_order();\n    compute_solution();\n  }\n\n  void read_input() {\n    std::cin >> num_addresses >> num_lists;\n    successor_vertices.resize(num_addresses + 1);\n\n    for (int i = 1; i <= num_lists; i++) {\n      int num_elements;\n      std::cin >> num_elements;\n      std::copy_n(std::istream_iterator<int>(std::cin), num_elements,\n                  std::back_inserter(successor_vertices[i]));\n    }\n  }\n\n  void compute_topological_order() {\n    visited = std::vector<bool>(num_addresses + 1, false);\n    dfs(1);\n  }\n\n  void dfs(int visiting) {\n    visited[visiting] = true;\n    for (auto next : successor_vertices[visiting])\n      if (!visited[next])\n        dfs(next);\n    topologic_order.push_back(visiting);\n  }\n\n  bool is_client_email(int index) { return index > num_lists; }\n\n  void compute_solution() {\n    single_emails =\n        std::count_if(std::begin(topologic_order), std::end(topologic_order),\n                      [&](auto address) { return is_client_email(address); });\n\n    auto num_emails = std::vector<uint64_t>(num_addresses + 1, 0);\n\n    for (auto node : topologic_order) {\n      if (is_client_email(node))\n        num_emails[node] = 1;\n      else {\n        num_emails[node] = std::accumulate(\n            std::begin(successor_vertices[node]),\n            std::end(successor_vertices[node]), uint64_t{0},\n            [&](auto sum, auto next) {\n              return (sum + num_emails[next]) % (1000000000 + 7);\n            });\n      }\n    }\n\n    spam_emails = num_emails[1];\n  }\n\n  int num_addresses;\n  int num_lists;\n  std::vector<std::vector<int>> successor_vertices;\n  std::vector<int> topologic_order;\n  std::vector<bool> visited;\n\n  uint64_t spam_emails;\n  uint64_t single_emails;\n};\n\nint main() {\n  auto ans = Solver{};\n  std::cout << ans.spam_emails << " " << ans.single_emails;\n  return 0;\n}\n')),Object(a.b)("div",{className:"footnotes"},Object(a.b)("hr",{parentName:"div"}),Object(a.b)("ol",{parentName:"div"},Object(a.b)("li",Object(i.a)({parentName:"ol"},{id:"fn-1"}),"Technically, this is the reverse of the topological order.",Object(a.b)("a",Object(i.a)({parentName:"li"},{href:"#fnref-1",className:"footnote-backref"}),"\u21a9")),Object(a.b)("li",Object(i.a)({parentName:"ol"},{id:"fn-2"}),"The ",Object(a.b)("inlineCode",{parentName:"li"},"visited")," vector is initialized with ",Object(a.b)("inlineCode",{parentName:"li"},"num_addresses + 1")," booleans,\nall initially set to false. The ",Object(a.b)("inlineCode",{parentName:"li"},"+ 1")," is there because the problem input is not\n0 based.",Object(a.b)("a",Object(i.a)({parentName:"li"},{href:"#fnref-2",className:"footnote-backref"}),"\u21a9")))))}c.isMDXComponent=!0},69:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return u}));var i=n(0),a=n.n(i);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=a.a.createContext({}),b=function(e){var t=a.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=b(e.components);return a.a.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},d=a.a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),p=b(n),d=i,u=p["".concat(l,".").concat(d)]||p[d]||m[d]||o;return n?a.a.createElement(u,s(s({ref:t},c),{},{components:n})):a.a.createElement(u,s({ref:t},c))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,l=new Array(o);l[0]=d;var s={};for(var r in t)hasOwnProperty.call(t,r)&&(s[r]=t[r]);s.originalType=e,s.mdxType="string"==typeof e?e:i,l[1]=s;for(var c=2;c<o;c++)l[c]=n[c];return a.a.createElement.apply(null,l)}return a.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},91:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/ex_1-a23c68fc81492e3d6d4268117c614e32.png"}}]);