(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{118:function(e,t,i){"use strict";i.r(t),t.default="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gR2VuZXJhdGVkIGJ5IGdyYXBodml6IHZlcnNpb24gMi40Mi4zICgwKQogLS0+Cgo8IS0tIFRpdGxlOiBDRkcgZm9yICYjMzk7X1o5Z2V0X3ZhbHVldiYjMzk7IGZ1bmN0aW9uIFBhZ2VzOiAxIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiCiAgIHhtbG5zOmlua3NjYXBlPSJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlIgogICB3aWR0aD0iNjg0cHQiCiAgIGhlaWdodD0iMzU0LjM2MnB0IgogICB2aWV3Qm94PSIwIDAgNjg0IDM1NC4zNjIiCiAgIHZlcnNpb249IjEuMSIKICAgaWQ9InN2Zzc3IgogICBzb2RpcG9kaTpkb2NuYW1lPSJjZmcuc3ZnIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjkyLjQgNWRhNjg5YzMxMywgMjAxOS0wMS0xNCI+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhODMiPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgICAgPGRjOnRpdGxlIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM4MSIgLz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEiCiAgICAgb2JqZWN0dG9sZXJhbmNlPSIxMCIKICAgICBncmlkdG9sZXJhbmNlPSIxMCIKICAgICBndWlkZXRvbGVyYW5jZT0iMTAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjE5MTYiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iMTA0NSIKICAgICBpZD0ibmFtZWR2aWV3NzkiCiAgICAgc2hvd2dyaWQ9ImZhbHNlIgogICAgIGZpdC1tYXJnaW4tdG9wPSIxNSIKICAgICBmaXQtbWFyZ2luLWxlZnQ9IjE1IgogICAgIGZpdC1tYXJnaW4tcmlnaHQ9IjE1IgogICAgIGZpdC1tYXJnaW4tYm90dG9tPSIxNSIKICAgICBpbmtzY2FwZTp6b29tPSIwLjg0NzI0NDQzIgogICAgIGlua3NjYXBlOmN4PSIyMjYuMDU4NDMiCiAgICAgaW5rc2NhcGU6Y3k9IjE3My41NTQ4NCIKICAgICBpbmtzY2FwZTp3aW5kb3cteD0iMCIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMTYiCiAgICAgaW5rc2NhcGU6d2luZG93LW1heGltaXplZD0iMCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjIiIC8+CiAgPGcKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjIiCiAgICAgaW5rc2NhcGU6bGFiZWw9ImJnIj4KICAgIDxyZWN0CiAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDowLjc1O3N0cm9rZS1vcGFjaXR5OjAuMDExNjI3OTIiCiAgICAgICBpZD0icmVjdDkzNCIKICAgICAgIHdpZHRoPSI2OTYuMDUyOTgiCiAgICAgICBoZWlnaHQ9IjM2NC4zMDExNSIKICAgICAgIHg9Ii0xLjI1MTg5NCIKICAgICAgIHk9Ii0zLjY3OTY2NzUiIC8+CiAgPC9nPgogIDxnCiAgICAgaWQ9ImdyYXBoMCIKICAgICBjbGFzcz0iZ3JhcGgiCiAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTUuNSwzMzkuODYyMDIpIj4KICAgIDx0aXRsZQogICAgICAgaWQ9InRpdGxlMiI+Q0ZHIGZvciAnX1o5Z2V0X3ZhbHVldicgZnVuY3Rpb248L3RpdGxlPgogICAgPCEtLSBOb2RlMHg1NWUxOTFlN2NhZDAgLS0+CiAgICA8IS0tIE5vZGUweDU1ZTE5MWU3Y2NkMCAtLT4KICAgIDwhLS0gTm9kZTB4NTVlMTkxZTdjYWQwJiM0NTsmZ3Q7Tm9kZTB4NTVlMTkxZTdjY2QwIC0tPgogICAgPCEtLSBOb2RlMHg1NWUxOTFlN2NkMjAgLS0+CiAgICA8IS0tIE5vZGUweDU1ZTE5MWU3Y2FkMCYjNDU7Jmd0O05vZGUweDU1ZTE5MWU3Y2QyMCAtLT4KICAgIDwhLS0gTm9kZTB4NTVlMTkxZTdjY2QwJiM0NTsmZ3Q7Tm9kZTB4NTVlMTkxZTdjZDIwIC0tPgogIDwvZz4KICA8ZwogICAgIGlua3NjYXBlOmdyb3VwbW9kZT0ibGF5ZXIiCiAgICAgaWQ9ImxheWVyMSIKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBzdHlsZT0iZGlzcGxheTppbmxpbmUiPgogICAgPHRleHQKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE1LjUsMzM5Ljg2MjAyKSIKICAgICAgIHg9IjM0MyIKICAgICAgIHk9Ii0zMTUuMzAwMDIiCiAgICAgICBmb250LXNpemU9IjE0LjAwIgogICAgICAgaWQ9InRleHQ2IgogICAgICAgc3R5bGU9ImZvbnQtc2l6ZToxNHB4O2ZvbnQtZmFtaWx5OlRpbWVzLCBzZXJpZjt0ZXh0LWFuY2hvcjptaWRkbGUiPkNGRyBmb3IgJ2dldF92YWx1ZScgZnVuY3Rpb248L3RleHQ+CiAgICA8ZwogICAgICAgaWQ9Im5vZGUxIgogICAgICAgY2xhc3M9Im5vZGUiCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNS41LDM2Mi4zNjIwMikiPgogICAgICA8dGl0bGUKICAgICAgICAgaWQ9InRpdGxlOCI+Tm9kZTB4NTVlMTkxZTdjYWQwPC90aXRsZT4KICAgICAgPHBvbHlnb24KICAgICAgICAgcG9pbnRzPSI2NTMsLTMyNC41IDY1MywtMjMzLjUgMjQxLC0yMzMuNSAyNDEsLTMyNC41ICIKICAgICAgICAgaWQ9InBvbHlnb24xMCIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMCIgLz4KICAgICAgPHRleHQKICAgICAgICAgeD0iMjQ5IgogICAgICAgICB5PSItMjk0LjI5OTk5IgogICAgICAgICBmb250LXNpemU9IjE0LjAwIgogICAgICAgICBpZD0idGV4dDE0IgogICAgICAgICBzdHlsZT0iZm9udC1zaXplOjE0cHg7Zm9udC1mYW1pbHk6VGltZXMsIHNlcmlmO3RleHQtYW5jaG9yOnN0YXJ0Ij4lMSA9IGxvYWQgaTgsIGk4KiBAX1pHVlo5Z2V0X3ZhbHVldkUxMW9wdGltaXplX21lPC90ZXh0PgogICAgICA8dGV4dAogICAgICAgICB4PSIyNDkiCiAgICAgICAgIHk9Ii0yNzkuMjk5OTkiCiAgICAgICAgIGZvbnQtc2l6ZT0iMTQuMDAiCiAgICAgICAgIGlkPSJ0ZXh0MTYiCiAgICAgICAgIHN0eWxlPSJmb250LXNpemU6MTRweDtmb250LWZhbWlseTpUaW1lcywgc2VyaWY7dGV4dC1hbmNob3I6c3RhcnQiPiUyID0gaWNtcCBlcSBpOCAlMSwgMDwvdGV4dD4KICAgICAgPHRleHQKICAgICAgICAgeD0iMjQ5IgogICAgICAgICB5PSItMjY0LjI5OTk5IgogICAgICAgICBmb250LXNpemU9IjE0LjAwIgogICAgICAgICBpZD0idGV4dDE4IgogICAgICAgICBzdHlsZT0iZm9udC1zaXplOjE0cHg7Zm9udC1mYW1pbHk6VGltZXMsIHNlcmlmO3RleHQtYW5jaG9yOnN0YXJ0Ij5iciBpMSAlMiwgbGFiZWwgJTMsIGxhYmVsICU0PC90ZXh0PgogICAgICA8cG9seWxpbmUKICAgICAgICAgcG9pbnRzPSIyNDEsLTI1Ni41IDY1MywtMjU2LjUgIgogICAgICAgICBpZD0icG9seWxpbmUyMCIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMCIgLz4KICAgICAgPHRleHQKICAgICAgICAgeD0iMzQ0IgogICAgICAgICB5PSItMjQxLjMiCiAgICAgICAgIGZvbnQtc2l6ZT0iMTQuMDAiCiAgICAgICAgIGlkPSJ0ZXh0MjIiCiAgICAgICAgIHN0eWxlPSJmb250LXNpemU6MTRweDtmb250LWZhbWlseTpUaW1lcywgc2VyaWY7dGV4dC1hbmNob3I6bWlkZGxlIj5UPC90ZXh0PgogICAgICA8cG9seWxpbmUKICAgICAgICAgcG9pbnRzPSI0NDcsLTIzMy41IDQ0NywtMjU2LjUgIgogICAgICAgICBpZD0icG9seWxpbmUyNCIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMCIgLz4KICAgICAgPHRleHQKICAgICAgICAgeD0iNTUwIgogICAgICAgICB5PSItMjQxLjMiCiAgICAgICAgIGZvbnQtc2l6ZT0iMTQuMDAiCiAgICAgICAgIGlkPSJ0ZXh0MjYiCiAgICAgICAgIHN0eWxlPSJmb250LXNpemU6MTRweDtmb250LWZhbWlseTpUaW1lcywgc2VyaWY7dGV4dC1hbmNob3I6bWlkZGxlIj5GPC90ZXh0PgogICAgPC9nPgogICAgPGcKICAgICAgIGlkPSJnODYxIj4KICAgICAgPGcKICAgICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTUuNSwzNjIuMzYyMDIpIgogICAgICAgICBjbGFzcz0ibm9kZSIKICAgICAgICAgaWQ9Im5vZGUyIj4KICAgICAgICA8dGl0bGUKICAgICAgICAgICBpZD0idGl0bGUyOSI+Tm9kZTB4NTVlMTkxZTdjY2QwPC90aXRsZT4KICAgICAgICA8cG9seWdvbgogICAgICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDAiCiAgICAgICAgICAgaWQ9InBvbHlnb24zMSIKICAgICAgICAgICBwb2ludHM9IjAsLTExMy41IDAsLTE5Ni41IDU3OCwtMTk2LjUgNTc4LC0xMTMuNSAiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMC44MDE1MDM1NiwwLDAsMS4wMDEzODQzLC0wLjA2ODU1NzYzLDAuMjE0NTU0NzIpIiAvPgogICAgICAgIDx0ZXh0CiAgICAgICAgICAgc3R5bGU9ImZvbnQtc2l6ZToxNHB4O2ZvbnQtZmFtaWx5OlRpbWVzLCBzZXJpZjt0ZXh0LWFuY2hvcjpzdGFydCIKICAgICAgICAgICBpZD0idGV4dDMzIgogICAgICAgICAgIGZvbnQtc2l6ZT0iMTQuMDAiCiAgICAgICAgICAgeT0iLTE4MS4zIgogICAgICAgICAgIHg9IjgiPiUzOjwvdGV4dD4KICAgICAgICA8dGV4dAogICAgICAgICAgIHN0eWxlPSJmb250LXNpemU6MTRweDtmb250LWZhbWlseTpUaW1lcywgc2VyaWY7dGV4dC1hbmNob3I6c3RhcnQiCiAgICAgICAgICAgaWQ9InRleHQzNyIKICAgICAgICAgICBmb250LXNpemU9IjE0LjAwIgogICAgICAgICAgIHk9Ii0xNTAuMDQ4MTEiCiAgICAgICAgICAgeD0iOCI+Y2FsbCB2b2lkIEBfWk41U3RhdGVDMkV2KCVzdHJ1Y3QuU3RhdGUqIEBfWlo5Z2V0X3ZhbHVldkUxMW9wdGltaXplX21lKTwvdGV4dD4KICAgICAgICA8dGV4dAogICAgICAgICAgIHN0eWxlPSJmb250LXNpemU6MTRweDtmb250LWZhbWlseTpUaW1lcywgc2VyaWY7dGV4dC1hbmNob3I6c3RhcnQiCiAgICAgICAgICAgaWQ9InRleHQzOSIKICAgICAgICAgICBmb250LXNpemU9IjE0LjAwIgogICAgICAgICAgIHk9Ii0xMzYuMyIKICAgICAgICAgICB4PSI4Ij5zdG9yZSBpOCAxLCBpOCogQF9aR1ZaOWdldF92YWx1ZXZFMTFvcHRpbWl6ZV9tZTwvdGV4dD4KICAgICAgICA8dGV4dAogICAgICAgICAgIHN0eWxlPSJmb250LXNpemU6MTRweDtmb250LWZhbWlseTpUaW1lcywgc2VyaWY7dGV4dC1hbmNob3I6c3RhcnQiCiAgICAgICAgICAgaWQ9InRleHQ0MSIKICAgICAgICAgICBmb250LXNpemU9IjE0LjAwIgogICAgICAgICAgIHk9Ii0xMjEuMyIKICAgICAgICAgICB4PSI4Ij5iciBsYWJlbCAlNDwvdGV4dD4KICAgICAgPC9nPgogICAgPC9nPgogICAgPGcKICAgICAgIGlkPSJlZGdlMSIKICAgICAgIGNsYXNzPSJlZGdlIgogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTUuNSwzNjIuMzYyMDIpIj4KICAgICAgPHRpdGxlCiAgICAgICAgIGlkPSJ0aXRsZTQ0Ij5Ob2RlMHg1NWUxOTFlN2NhZDA6czAtJmd0O05vZGUweDU1ZTE5MWU3Y2NkMDwvdGl0bGU+CiAgICAgIDxwYXRoCiAgICAgICAgIGQ9Im0gMzQ0LC0yMzMgYyAwLDkuNzUgLTIuOTYsMTkuMTMgLTcuNSwyNy43NyIKICAgICAgICAgaWQ9InBhdGg0NiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMCIgLz4KICAgICAgPHBvbHlnb24KICAgICAgICAgcG9pbnRzPSIzMzkuNCwtMjAzLjI3IDMzMS4yNCwtMTk2LjUxIDMzMy40LC0yMDYuODggIgogICAgICAgICBpZD0icG9seWdvbjQ4IgogICAgICAgICBzdHlsZT0iZmlsbDojMDAwMDAwO3N0cm9rZTojMDAwMDAwIiAvPgogICAgPC9nPgogICAgPGcKICAgICAgIGlkPSJub2RlMyIKICAgICAgIGNsYXNzPSJub2RlIgogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTUuNSwzNjIuMzYyMDIpIj4KICAgICAgPHRpdGxlCiAgICAgICAgIGlkPSJ0aXRsZTUxIj5Ob2RlMHg1NWUxOTFlN2NkMjA8L3RpdGxlPgogICAgICA8cG9seWdvbgogICAgICAgICBwb2ludHM9IjQ5MywtMjMuNSA0MDEsLTIzLjUgNDAxLC03Ni41IDQ5MywtNzYuNSAiCiAgICAgICAgIGlkPSJwb2x5Z29uNTMiCiAgICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDAiIC8+CiAgICAgIDx0ZXh0CiAgICAgICAgIHg9IjQwOSIKICAgICAgICAgeT0iLTYxLjI5OTk5OSIKICAgICAgICAgZm9udC1zaXplPSIxNC4wMCIKICAgICAgICAgaWQ9InRleHQ1NSIKICAgICAgICAgc3R5bGU9ImZvbnQtc2l6ZToxNHB4O2ZvbnQtZmFtaWx5OlRpbWVzLCBzZXJpZjt0ZXh0LWFuY2hvcjpzdGFydCI+JTQ6PC90ZXh0PgogICAgICA8dGV4dAogICAgICAgICB4PSI0MDkiCiAgICAgICAgIHk9Ii0zNy4yOTk5OTkiCiAgICAgICAgIGZvbnQtc2l6ZT0iMTQuMDAiCiAgICAgICAgIGlkPSJ0ZXh0NTkiCiAgICAgICAgIHN0eWxlPSJmb250LXNpemU6MTRweDtmb250LWZhbWlseTpUaW1lcywgc2VyaWY7dGV4dC1hbmNob3I6c3RhcnQiPnJldCBpMzIgNDI8L3RleHQ+CiAgICA8L2c+CiAgICA8ZwogICAgICAgaWQ9ImVkZ2UyIgogICAgICAgY2xhc3M9ImVkZ2UiCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNS41LDM2Mi4zNjIwMikiPgogICAgICA8dGl0bGUKICAgICAgICAgaWQ9InRpdGxlNjIiPk5vZGUweDU1ZTE5MWU3Y2FkMDpzMS0mZ3Q7Tm9kZTB4NTVlMTkxZTdjZDIwPC90aXRsZT4KICAgICAgPHBhdGgKICAgICAgICAgZD0ibSA1NTAsLTIzMyBjIDAsMjIuOTQgMjguMDcsMTQuODYgMzcsMzYgMTQuNTIsMzQuMzkgMjAuMzYsNTIuNzEgMCw4NCAtMTguNSwyOC40MiAtNTMuMzMsNDMuOTIgLTgzLjYyLDUyLjMxIgogICAgICAgICBpZD0icGF0aDY0IgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwIiAvPgogICAgICA8cG9seWdvbgogICAgICAgICBwb2ludHM9IjUwMi4xMywtNjMuOTkgNTAzLjg3LC01Ny4yMSA0OTMuMzEsLTU4LjExICIKICAgICAgICAgaWQ9InBvbHlnb242NiIKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtzdHJva2U6IzAwMDAwMCIgLz4KICAgIDwvZz4KICAgIDxnCiAgICAgICBpZD0iZWRnZTMiCiAgICAgICBjbGFzcz0iZWRnZSIKICAgICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE1LjUsMzYyLjM2MjAyKSI+CiAgICAgIDx0aXRsZQogICAgICAgICBpZD0idGl0bGU2OSI+Tm9kZTB4NTVlMTkxZTdjY2QwLSZndDtOb2RlMHg1NWUxOTFlN2NkMjA8L3RpdGxlPgogICAgICA8cGF0aAogICAgICAgICBkPSJtIDM1MS40NSwtMTEzLjI5IGMgMTUuODYsMTAuMzQgMzIuNjUsMjEuMjkgNDcuNjcsMzEuMDciCiAgICAgICAgIGlkPSJwYXRoNzEiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDAiIC8+CiAgICAgIDxwb2x5Z29uCiAgICAgICAgIHBvaW50cz0iNDA3LjczLC03Ni42IDM5Ny40NCwtNzkuMTMgNDAxLjI2LC04NC45OSAiCiAgICAgICAgIGlkPSJwb2x5Z29uNzMiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7c3Ryb2tlOiMwMDAwMDAiIC8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4K"},62:function(e,t,i){"use strict";i.r(t),i.d(t,"frontMatter",(function(){return l})),i.d(t,"metadata",(function(){return c})),i.d(t,"rightToc",(function(){return r})),i.d(t,"default",(function(){return I}));var n=i(2),a=i(6),o=(i(0),i(69)),l={title:"Static variables, static storage, static initialization, constant initialization, constinit, constexpr",slug:"../const_constinit_constexpr_consteval"},c={unversionedId:"20200306-static_var/README",id:"20200306-static_var/README",isDocsHomePage:!1,title:"Static variables, static storage, static initialization, constant initialization, constinit, constexpr",description:"In a recent discussion over Twitter, it was pointed out that optimizers",source:"@site/docs/20200306-static_var/README.md",slug:"/const_constinit_constexpr_consteval",permalink:"/const_constinit_constexpr_consteval",version:"current",sidebar:"someSidebar",previous:{title:"A Git introduction with no commands",permalink:"/git_basics"},next:{title:"Build system basics - part 2",permalink:"/build_system_p2"}},r=[{value:"The offending code.",id:"the-offending-code",children:[]},{value:"Optimized code",id:"optimized-code",children:[{value:"Static storage",id:"static-storage",children:[]},{value:"Zero or Constant initialization",id:"zero-or-constant-initialization",children:[]},{value:"Constant initialization to the rescue!",id:"constant-initialization-to-the-rescue",children:[]}]},{value:"Don&#39;t let slow code compile.",id:"dont-let-slow-code-compile",children:[]},{value:"But we can&#39;t constexpr all the things",id:"but-we-cant-constexpr-all-the-things",children:[]},{value:"Conclusion",id:"conclusion",children:[]}],g={rightToc:r};function I(e){var t=e.components,l=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(n.a)({},g,l,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"In a recent discussion over Twitter, it was pointed out that optimizers\nfailed to eliminate a function-scope static variable with no uses. This article\nexplores why the optimizer struggles with such code patterns, how static\nvariables are stored and initialized, and also how certain C++ keywords can\nhelp the optimizer do its job."),Object(o.b)("p",null,"Disclaimer: Godbolt links will be used but, instead of inspecting x86 assembly,\nthe target will be LLVM's Intermediate Representation (IR). It is almost always\nsimpler to use IR instead of assembly:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Most operations and types are spelled out explicitly."),Object(o.b)("li",{parentName:"ul"},"The data section is easier to visualize."),Object(o.b)("li",{parentName:"ul"},"The compiler transformations we're interested in are, more often than not,\narchitecture-independent and happen before the compiler generates assembly.\nTherefore we can keep a higher level of abstraction (IR) that is easier to\nreason about."),Object(o.b)("li",{parentName:"ul"},"We get to see what the compiler does to obey the C++ standard much earlier:\nall the rules must be captured in the translation from C++ to IR and, from\nthere on, all optimizations are game - the standard doesn't exist anymore.")),Object(o.b)("p",null,"Everything necessary about IR will be explained, but if you want to learn more,\nI presented ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://www.youtube.com/watch?v=m8G_S5LwlTo"}),"a tutorial")," during the EuroLLVM developers conference in 2019."),Object(o.b)("h2",{id:"the-offending-code"},"The offending code."),Object(o.b)("p",null,"The ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://twitter.com/lefticus/status/1221943946311454721"}),"original tweet")," used this example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),'#include <string>\n\nint static_version() {\n    static const std::string unused_variable{"static"};\n    return 42;\n}\n\nint local_version() {\n    const std::string unused_variable{"local"};\n    return 42;\n}\n')),Object(o.b)("p",null,"The author mentions how, in the static case, ",Object(o.b)("inlineCode",{parentName:"p"},"unused_variable")," doesn't get\noptimized away but, in the local variable case, the optimizer does a much\nbetter job."),Object(o.b)("p",null,"Because ",Object(o.b)("inlineCode",{parentName:"p"},"std::string")," has a complicated constructor, I'll rewrite this code\nusing the simplest class possible:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"struct State {\n    State() {}\n};\n\nint get_value(){\n    static State optimize_me;\n    return 42;\n}\n")),Object(o.b)("p",null,"It's reasonable to expect that ",Object(o.b)("inlineCode",{parentName:"p"},"State optimize_me")," will be optimized away: it\nis a function-scope static variable with no uses. Unfortunately, both GCC and\nClang fail to do so."),Object(o.b)("p",null,"To understand what's going here, let's look at the ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://godbolt.org/z/AGa_4M"}),"IR produced by Clang")," without\noptimizations",Object(o.b)("sup",Object(n.a)({parentName:"p"},{id:"fnref-1"}),Object(o.b)("a",Object(n.a)({parentName:"sup"},{href:"#fn-1",className:"footnote-ref"}),"1")),"."),Object(o.b)("p",null,"First, a type ",Object(o.b)("inlineCode",{parentName:"p"},"struct.State")," is defined:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-llvm"}),"%struct.State = type { i8 }\n")),Object(o.b)("p",null,"Our C++ struct has no data members, and yet its equivalent in IR contains an\n8-bit integer (",Object(o.b)("inlineCode",{parentName:"p"},"i8"),"). What is ",Object(o.b)("inlineCode",{parentName:"p"},"sizeof(State)"),"? Having seen the IR, the answer is\neasy to guess: 1 byte ",Object(o.b)("sup",Object(n.a)({parentName:"p"},{id:"fnref-2"}),Object(o.b)("a",Object(n.a)({parentName:"sup"},{href:"#fn-2",className:"footnote-ref"}),"2")),"."),Object(o.b)("p",null,"Then, a global variable of that type is defined and initialized:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-llvm"}),"@_ZZ10get_value2vE11optimize_me = internal global %struct.State zeroinitializer\n")),Object(o.b)("p",null,"Note that this variable is initialized with the ",Object(o.b)("inlineCode",{parentName:"p"},"zeroinitializer")," keyword. That\nmeans its memory region will be set to zero  ",Object(o.b)("strong",{parentName:"p"},"before the program starts"),".\nBut... We haven't initialized our C++ variable at all! We'll talk more about\nthis later."),Object(o.b)("p",null,"There is another global variable in our module, with a very similar name:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-llvm"}),"@_ZGVZ10get_value2vE11optimize_me = internal global i8 0\n")),Object(o.b)("p",null,"Note again how this variable is zero initialized, this time by writing ",Object(o.b)("inlineCode",{parentName:"p"},"i8 0"),"\n(this is equivalent to ",Object(o.b)("inlineCode",{parentName:"p"},"zeroinitializer"),")."),Object(o.b)("p",null,"This is very mysterious: an 8-bit integer that we never wrote in the original\nC++ code. Let's look at the body of our ",Object(o.b)("inlineCode",{parentName:"p"},"get_value")," function to find out more:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-llvm"}),"define i32 @_Z10get_valuev() #0 {\n  %1 = load i8, i8* @_ZGVZ10get_value2vE11optimize_me\n  %2 = icmp eq i8 %1, 0\n  br i1 %2, label %3, label %4\n\n")),Object(o.b)("p",null,"The first line loads the mysterious variable and the second line compares it\nto 0. If the value is zero, the code branches to this block:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-llvm"}),"3:\n  call void @_ZN5StateC2Ev(%struct.State* @_ZZ10get_value2vE11optimize_me)\n  store i8 1, i8* @_ZGVZ10get_value2vE11optimize_me\n  br label %4\n\n")),Object(o.b)("p",null,"A function call with our static variable as its first argument -- this is a\ncall to ",Object(o.b)("inlineCode",{parentName:"p"},"State"),"'s constructor! Right after that, we update the value of the\nmysterious variable by storing ",Object(o.b)("inlineCode",{parentName:"p"},"1")," to it."),Object(o.b)("p",null,"Afterwards, or if the original comparison to zero failed, code execution\nproceeds to return ",Object(o.b)("inlineCode",{parentName:"p"},"42"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-llvm"}),"4:\n  ret i32 42\n}\n")),Object(o.b)("p",null,"A visual representation can be found in the ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Control-flow_graph"}),"control flow graph")," for this\nfunction:"),Object(o.b)("p",null,Object(o.b)("img",{alt:"example 1",src:i(118).default})),Object(o.b)("p",null,"This example illustrates the code generated in order to initialize\nfunction-scope static variables. The compiler must guarantee that the\nconstructor is called exactly once, during the first time execution passes\nthrough the static variable declaration. This is accomplished with the pattern:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Global counter initialized to 0"),Object(o.b)("li",{parentName:"ul"},"If counter is zero:",Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"Call constructor."),Object(o.b)("li",{parentName:"ul"},"Set counter to 1.")))),Object(o.b)("h2",{id:"optimized-code"},"Optimized code"),Object(o.b)("p",null,"Is the optimizer able to remove all of the code in that function?\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://godbolt.org/z/KMCFPD"}),"Take a look"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-llvm"}),"@_ZGVZ9get_valuevE11optimize_me = internal unnamed_addr global i1 false\n\ndefine i32 @_Z9get_valuev() {\n  %1 = load i1, i1* @_ZGVZ9get_valuevE11optimize_me\n  br i1 %1, label %3, label %2\n\n2:\n  store i1 true, i1* @_ZGVZ9get_valuevE11optimize_me\n  br label %3\n\n3:\n  ret i32 42\n}\n")),Object(o.b)("p",null,"Note that the optimizer:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"Deleted the ",Object(o.b)("em",{parentName:"li"},"static")," variable."),Object(o.b)("li",{parentName:"ol"},"Deleted the call to its constructor."),Object(o.b)("li",{parentName:"ol"},"Transformed the global counter into a boolean (from ",Object(o.b)("inlineCode",{parentName:"li"},"i8")," to ",Object(o.b)("inlineCode",{parentName:"li"},"i1"),")."),Object(o.b)("li",{parentName:"ol"},"Failed to optimize away this global boolean.")),Object(o.b)("p",null,"Point #4 is a hard problem because the counter will make the first call to\n",Object(o.b)("inlineCode",{parentName:"p"},"get_value")," take a different code path from subsequent calls. Furthermore,\nthe two paths have distinct behaviors: one writes to a global variable, the\nother doesn't. To delete the counter:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"The optimizer needs to prove that the change in the ",Object(o.b)("strong",{parentName:"li"},"counter's value")," isn't\nmeaningful to the program."),Object(o.b)("li",{parentName:"ol"},"But it is meaningful because it affects control flow inside ",Object(o.b)("inlineCode",{parentName:"li"},"get_value"),"."),Object(o.b)("li",{parentName:"ol"},"So the optimizer needs to prove that control flow inside ",Object(o.b)("inlineCode",{parentName:"li"},"get_value")," isn't\nmeaningful to the program."),Object(o.b)("li",{parentName:"ol"},"But it is meaningful because control flow affects the ",Object(o.b)("strong",{parentName:"li"},"counter's value"),".")),Object(o.b)("p",null,"... And now we're stuck in a loop! It's not an unsolvable problem, but it\nillustrates challenges the optimizer can't overcome right now",Object(o.b)("sup",Object(n.a)({parentName:"p"},{id:"fnref-3"}),Object(o.b)("a",Object(n.a)({parentName:"sup"},{href:"#fn-3",className:"footnote-ref"}),"3")),"."),Object(o.b)("p",null,"This situation gets worse if the constructor call isn't as simple as an empty\nfunction. Our motivating example, ",Object(o.b)("inlineCode",{parentName:"p"},"std::string"),", definitely doesn't have a\nsimple constructor."),Object(o.b)("p",null,"##Can we do better ?"),Object(o.b)("p",null,"We can. We can help the compiler by expressing our intent more appropriately.\nBut first, we need to understand how static variables are initialized."),Object(o.b)("h3",{id:"static-storage"},"Static storage"),Object(o.b)("p",null,"Static variables have what is known as static storage. From cppreference:"),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"The storage for the object is allocated when the program begins and\ndeallocated when the program ends. Only one instance of the object exists.")),Object(o.b)("p",null,"In practice, we see the storage for static variables in the data segment of the\nprogram, in other words, the storage is available when the program is\n",Object(o.b)("strong",{parentName:"p"},"loaded"),". Moreover, the initial contents of that memory region are also\nspecified in the data segment and available when the program is loaded; but\nwhat exactly are those contents and can we influence them?"),Object(o.b)("h3",{id:"zero-or-constant-initialization"},"Zero or Constant initialization"),Object(o.b)("p",null,"Let's look at what cppreference tells us (emphasis mine):"),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"Variables declared at block scope with the specifier static","[...]"," are\ninitialized the first time control passes through their declaration( ",Object(o.b)("strong",{parentName:"p"},"unless\ntheir initialization is zero - or constant - initialization"),", which can be\nperformed before the block is first entered) . ","[",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://en.cppreference.com/w/cpp/language/storage_duration#Static_local_variables"}),"static local variables"),"]")),Object(o.b)("p",null,"Intuitively, zero-initialization is what it sounds like: when the program is\nloaded, that region of memory gets zero initialized. Typically, if other\ninitialization is necessary, like running constructors or evaluating\nconstructor arguments, it will happen at runtime. Not very exciting."),Object(o.b)("p",null,"Constant-initialization, when possible, happens instead of zero-initialization.\nThe details are complicated, but it essentially boils down to whether you have\na constant expression initializing the static variable. Cppreference uses the\nfollowing notation to explain this idea:"),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},Object(o.b)("inlineCode",{parentName:"p"},"static T object = constexpr;"))),Object(o.b)("p",null,"The best part is that constant-initialization will typically remove the need\nfor runtime initialization. Let's look at what this looks like in IR."),Object(o.b)("h3",{id:"constant-initialization-to-the-rescue"},"Constant initialization to the rescue!"),Object(o.b)("p",null,"Let's make our example slightly more complicated, ",Object(o.b)("strong",{parentName:"p"},"disable all\noptimizations"),", but have a ",Object(o.b)("inlineCode",{parentName:"p"},"constexpr")," constructor:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"struct State {\n  constexpr State(char c1, char c2, char c3)\n      : value1{c1}, value2{c2}, value3{c3} {}\n  char value1;\n  char value2;\n  char value3;\n};\n\nint get_value() {\n  static State optimize_me(1, 2, 3);\n  return 42;\n}\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"constexpr")," functions are a mechanism through which programmers express their\ndesire to have the function evaluated at compile time if the function is called\nwith compile time constant arguments.",Object(o.b)("sup",Object(n.a)({parentName:"p"},{id:"fnref-4"}),Object(o.b)("a",Object(n.a)({parentName:"sup"},{href:"#fn-4",className:"footnote-ref"}),"4"))),Object(o.b)("p",null,"Because our static variable is now initialized with a constant expression, the\nIR for this function now becomes much simpler:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-llvm"}),"@_ZZ9get_valuevE11optimize_me = internal global %struct.State { i8 1, i8 2, i8 3 }\n\ndefine i32 @_Z10get_valuev() {\n  ret i32 42\n}\n")),Object(o.b)("p",null,"To emphasize, this happens with no optimizations, this is a built in mechanism\nof the language, not a compiler transformation. ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://godbolt.org/z/Y7cGqx"}),"See for yourself"),"!"),Object(o.b)("p",null,"What happened here? Constant initialization took place, because we have a\nconstant expression (the constructor is ",Object(o.b)("inlineCode",{parentName:"p"},"constexpr")," and it is called with\nconstant arguments) initializing the ",Object(o.b)("inlineCode",{parentName:"p"},"optimize_me")," variable."),Object(o.b)("p",null,"In the non-",Object(o.b)("inlineCode",{parentName:"p"},"constexpr")," version, the IR global variable corresponding to the C++\nstatic variable was initialized by ",Object(o.b)("inlineCode",{parentName:"p"},"zeroinitializer"),", and inside the\n",Object(o.b)("inlineCode",{parentName:"p"},"get_value")," function we had a constructor call wrapped by some boilerplate to\nensure the variable was initialized exactly once. In other words, ",Object(o.b)("strong",{parentName:"p"},"zero\ninitialization + runtime initialization")," took place."),Object(o.b)("p",null,"In the ",Object(o.b)("inlineCode",{parentName:"p"},"constexpr")," version, all the boilerplate is gone because ",Object(o.b)("strong",{parentName:"p"},"constant\ninitialization happened instead of zero-initialization + runtime\ninitialization"),". This is the core idea of this post: if you enable constant\ninitialization, unnecessary code disappears."),Object(o.b)("p",null,"The generated assembly contains the already-initialized variable in the\ndata segment of the program:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"        .data\nget_value()::optimize_me:\n        .byte   1                       # 0x1\n        .byte   2                       # 0x2\n        .byte   3                       # 0x3\n        .size   get_value()::optimize_me, 3\n")),Object(o.b)("p",null,"With optimizations enabled, the static variable will be completely removed."),Object(o.b)("h2",{id:"dont-let-slow-code-compile"},"Don't let slow code compile."),Object(o.b)("p",null,"C++20 adds a new keyword ",Object(o.b)("inlineCode",{parentName:"p"},"constinit")," to ensure a variable only has constant\ninitialization, otherwise the program is ill-formed. For example, the following\ncode does not compile (note the absence of a ",Object(o.b)("inlineCode",{parentName:"p"},"constexpr")," constructor):"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-cpp"}),"struct State {\n  State(char c1, char c2, char c3) : value1{c1}, value2{c2}, value3{c3} {}\n  char value1;\n  char value2;\n  char value3;\n};\n\nint get_value(){\n  constinit static State optimize_me(1,2,3);\n  return 42;\n}\n")),Object(o.b)("p",null,"This is desirable because it prevents inefficient code from compiling.  If we\nmake ",Object(o.b)("inlineCode",{parentName:"p"},"State"),"'s constructor ",Object(o.b)("inlineCode",{parentName:"p"},"constexpr"),", the program is now legal and uses\nefficient constant initialization. ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://godbolt.org/z/TxrgSv"}),"Godbolt link")),Object(o.b)("h2",{id:"but-we-cant-constexpr-all-the-things"},"But we can't constexpr all the things"),Object(o.b)("p",null,"The original example dealt with a ",Object(o.b)("inlineCode",{parentName:"p"},"std::string")," static variable, which may\nperform dynamic memory allocation - which is not allowed in ",Object(o.b)("inlineCode",{parentName:"p"},"constexpr"),"\ncontexts. This is lifted in C++20 and most methods of ",Object(o.b)("inlineCode",{parentName:"p"},"std::string")," are made\n",Object(o.b)("inlineCode",{parentName:"p"},"constexpr")," thanks to ","[Louis Dionne's paper]",". No compilers implement this at the\ntime of writing, but you can check ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://gcc.gnu.org/onlinedocs/libstdc++/manual/status.html#status.iso.2020"}),"GCC's progress")," and ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://libcxx.llvm.org/cxx2a_status.html"}),"Clang's progress")," on\ntheir websites."),Object(o.b)("p",null,"Edit (2020-03-21): As Jason Turner pointed out on Twitter, ",Object(o.b)("inlineCode",{parentName:"p"},"constexpr")," dynamic\nallocation, while allowed in C++ 20, still needs to be freed in the same\n",Object(o.b)("inlineCode",{parentName:"p"},"constexpr")," context that allocated it. This implies that big ",Object(o.b)("inlineCode",{parentName:"p"},"constexpr")," strings\nare not going to be allowed."),Object(o.b)("h2",{id:"conclusion"},"Conclusion"),Object(o.b)("p",null,"Without entering the discussion of when/if static variables should be used,\nit's important to be aware of the price that is paid for their correct\ninitialization. In most cases, the programmer can completely avoid this price\nby using constant initialization (usually in the form of ",Object(o.b)("inlineCode",{parentName:"p"},"constexpr")," constructors\nand functions)."),Object(o.b)("p",null,"Furthermore, by expressing their intent properly to the compiler, it's possible\nto ensure a compilation error when code changes trigger inefficient\ninitialization; this is accomplished by marking the static variable as\n",Object(o.b)("inlineCode",{parentName:"p"},"constinit"),". A lot of new features in the C++ language are driven by the desire\nto allow programmers to communicate intent to the compiler (and to other\nprogrammers)."),Object(o.b)("p",null,"I also hope to have shown that using the LLVM IR makes it simpler to explore\narchitecture-agnostic missed optimizations. In the case explored here, there is\nno reason why a static variable should be optimized away when targeting x86,\nbut not when targeting ARM, for instance."),Object(o.b)("div",{className:"footnotes"},Object(o.b)("hr",{parentName:"div"}),Object(o.b)("ol",{parentName:"div"},Object(o.b)("li",Object(n.a)({parentName:"ol"},{id:"fn-1"}),"We're compiling the code without support for thread-safe static\ninitialization to keep things simple. However, most of our conclusion still\nhold if we enable thread safe statics.",Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"#fnref-1",className:"footnote-backref"}),"\u21a9")),Object(o.b)("li",Object(n.a)({parentName:"ol"},{id:"fn-2"}),"If you're curious why, the creator of C++ answers it in ",Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"http://www.stroustrup.com/bs_faq2.html#sizeof-empty"}),"his website"),".",Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"#fnref-2",className:"footnote-backref"}),"\u21a9")),Object(o.b)("li",Object(n.a)({parentName:"ol"},{id:"fn-3"}),"Other challenges are possible. For example, if\nthis function gets inlined elsewhere, we will have multiple functions accessing\nthe same global variable and the compiler will struggle reasoning about this.\nNote also that we don't have to consider other translation units because static\nvariables have internal linkage, that is, they can only be accessed from the\ntranslation unit in which it is defined; this is represented by the ",Object(o.b)("inlineCode",{parentName:"li"},"internal"),"\nkeyword in IR.",Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"#fnref-3",className:"footnote-backref"}),"\u21a9")),Object(o.b)("li",Object(n.a)({parentName:"ol"},{id:"fn-4"}),"There is a stronger form of this in the form of\nthe ",Object(o.b)("inlineCode",{parentName:"li"},"consteval")," keyword. When applied to a function, it is a compile-time error\nif the function is not evaluated at compile time. It is a useful mechanism to\nensure that an expensive function is never evaluated during program\nexecution.",Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"#fnref-4",className:"footnote-backref"}),"\u21a9")))))}I.isMDXComponent=!0},69:function(e,t,i){"use strict";i.d(t,"a",(function(){return s})),i.d(t,"b",(function(){return p}));var n=i(0),a=i.n(n);function o(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function l(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function c(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?l(Object(i),!0).forEach((function(t){o(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):l(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function r(e,t){if(null==e)return{};var i,n,a=function(e,t){if(null==e)return{};var i,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)i=o[n],t.indexOf(i)>=0||(a[i]=e[i]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)i=o[n],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(a[i]=e[i])}return a}var g=a.a.createContext({}),I=function(e){var t=a.a.useContext(g),i=t;return e&&(i="function"==typeof e?e(t):c(c({},t),e)),i},s=function(e){var t=I(e.components);return a.a.createElement(g.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},C=a.a.forwardRef((function(e,t){var i=e.components,n=e.mdxType,o=e.originalType,l=e.parentName,g=r(e,["components","mdxType","originalType","parentName"]),s=I(i),C=n,p=s["".concat(l,".").concat(C)]||s[C]||b[C]||o;return i?a.a.createElement(p,c(c({ref:t},g),{},{components:i})):a.a.createElement(p,c({ref:t},g))}));function p(e,t){var i=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=i.length,l=new Array(o);l[0]=C;var c={};for(var r in t)hasOwnProperty.call(t,r)&&(c[r]=t[r]);c.originalType=e,c.mdxType="string"==typeof e?e:n,l[1]=c;for(var g=2;g<o;g++)l[g]=i[g];return a.a.createElement.apply(null,l)}return a.a.createElement.apply(null,i)}C.displayName="MDXCreateElement"}}]);