<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.66">
<title data-react-helmet="true">A Git introduction with no commands | 101</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" name="docusaurus_language" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="A Git introduction with no commands | 101"><meta data-react-helmet="true" name="description" content="Using Git is a mandatory skill for any software engineer in today&#x27;s industry,"><meta data-react-helmet="true" property="og:description" content="Using Git is a mandatory skill for any software engineer in today&#x27;s industry,"><meta data-react-helmet="true" property="og:url" content="https://felipepiovezan.github.io//20200503-git_intro/README"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://felipepiovezan.github.io//20200503-git_intro/README"><link rel="stylesheet" href="/styles.58710d0f.css">
<link rel="preload" href="/styles.9959f271.js" as="script">
<link rel="preload" href="/runtime~main.5df455bb.js" as="script">
<link rel="preload" href="/main.01c6edad.js" as="script">
<link rel="preload" href="/1.43c5d01a.js" as="script">
<link rel="preload" href="/2.cf4e590e.js" as="script">
<link rel="preload" href="/13.c5726d0f.js" as="script">
<link rel="preload" href="/935f2afb.584f3aef.js" as="script">
<link rel="preload" href="/17896441.2afc73b6.js" as="script">
<link rel="preload" href="/8dded891.700a24dc.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><img class="navbar__logo" src="/img/logo.svg" alt="My Site Logo"><strong class="navbar__title">Blog</strong></a><a href="https://github.com/felipepiovezan" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><a href="https://twitter.com/fpiovezan" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Twitter</a><a href="https://linkedin.com/in/felipepiovezan" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">LinkedIn</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2aTZ"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_BsTx">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_BsTx">ðŸŒž</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img class="navbar__logo" src="/img/logo.svg" alt="My Site Logo"><strong class="navbar__title">Blog</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a href="https://github.com/felipepiovezan" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li><li class="menu__list-item"><a href="https://twitter.com/fpiovezan" target="_blank" rel="noopener noreferrer" class="menu__link">Twitter</a></li><li class="menu__list-item"><a href="https://linkedin.com/in/felipepiovezan" target="_blank" rel="noopener noreferrer" class="menu__link">LinkedIn</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_2gpo"><div class="docSidebarContainer_3_JD" role="complementary"><div class="sidebar_2urC"><div class="menu menu--responsive menu_5FrY"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_Dm3K" xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 32 32" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menuLinkText_2zSB">About me</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/">About me</a></li></ul></li><li class="menu__list-item"><a class="menu__link menuLinkText_2zSB">Posts</a><ul class="menu__list"><li class="menu__list-item"><a href="https://felipepiovezan.github.io/cpp_abstract_machine/cpp_abstract_machine" target="_blank" rel="noreferrer noopener" class="menu__link" tabindex="0">The C++ abstract machine [opens in new tab]</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/20200503-git_intro/README">A Git introduction with no commands</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/20200306-static_var/README">Static variables, static storage, static initialization, constant initialization, constinit, constexpr</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/20200222-build_systems2/README">Build system basics - part 2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/20200127-build_systems1/README">Build system basics</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/20191117-improve_spam/README">Topological sorting - ACM-ICPC</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3EyW"><div class="container padding-vert--lg docItemWrapper_1EkI"><div class="row"><div class="col docItemCol_2ASc"><div class="docItemContainer_3QWW"><article><header><h1 class="docTitle_1Lrw">A Git introduction with no commands</h1></header><div class="markdown"><p>Using Git is a mandatory skill for any software engineer in today&#x27;s industry,
but it&#x27;s surprisingly difficult to find an introduction to the mental model
behind Git. Most Git users repeat a set of memorized commands that work for
some situations, resorting to colleagues when the cheat sheet fails.</p><p>I used to be in that camp before opening the magic box behind the command line
interface. Having understood Git&#x27;s conceptual model, I am now able to use the
tool more effectively than before, employing it in ways that I didn&#x27;t know were
possible. By framing a problem as an operation on the commit history graph, I
can easily find the Git command I need to solve it.</p><p>With this post, I intend to go over Git&#x27;s conceptual model <em>without
mentioning a single command-line operation</em>. Once the model is clear, then we
look at daily actions performed by developers and map those actions to Git
concepts. This is my attempt at &quot;how I wish Git had been explained to me&quot;.</p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="saving-snapshots-of-the-project"></a>Saving snapshots of the project<a aria-hidden="true" tabindex="-1" class="hash-link" href="#saving-snapshots-of-the-project" title="Direct link to heading">#</a></h1><p>At its core, a version control system is a program that keeps track of the
state of a repository as it evolves through time. It allows us to go back and
forth between states, to record new states, and to inspect the &quot;history&quot; of the
repository.</p><p>In Git, saving a new state of the repository consists of:</p><ol><li>Making changes to files or adding new ones.</li><li>Specifying which changes should be recorded by adding those changes to the
<em>staging area</em>.</li><li>Performing a <em>commit</em> operation.</li></ol><p>For now, don&#x27;t worry about what this commit operation is, we&#x27;ll talk about it
soon.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="staging"></a>Staging<a aria-hidden="true" tabindex="-1" class="hash-link" href="#staging" title="Direct link to heading">#</a></h2><p>The staging area consists of a set of changes that will be included by the next
commit operation. It partitions the repository into three categories of files:</p><p><img alt="file_partitions" src="/assets/images/three_categories-db878eaf825e5e18c5f564518ff9e87a.svg"></p><p>During development, we are editing files, staging <em>changes</em>, and finally doing a
commit operation:</p><p><img alt="transitions 1" src="/assets/images/transitions1-ef284cdc831e6c0de35c93c42b471527.svg"></p><p>Nothing stops us from editing a file, staging it and editing the file again;
this effectively creates a new kind of file that has both staged and unstaged
changes. It&#x27;s up to us to decide what we want the next commit to include: if
it should include the new changes, then we have to stage them too.</p><p><img alt="transitions 2" src="/assets/images/transitions2-8862a6d1071e356df74adf8ed53585fb.svg"></p><p>Git also allows us to stage <em>some</em> of the changes in a file, in fact the mental
model is that we stage changes done to a file, not the file itself. Staging
only a subset of the changes done to a file is helpful in case they don&#x27;t all
logically belong on the same commit.</p><p><img alt="transitions 3" src="/assets/images/transitions3-b0382367031cc483bab7bdbdc93773ba.svg"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="commit-definition"></a>Commit definition<a aria-hidden="true" tabindex="-1" class="hash-link" href="#commit-definition" title="Direct link to heading">#</a></h2><p>So what is a commit operation?</p><p>When a commit is performed, <em>a snapshot of the entire repository is taken</em> and
stored into an internal data structure of Git. A commit operation creates a
commit object, which consists of:</p><ol><li>A pointer to that snapshot,</li><li>the author&#x27;s name and email,</li><li>a commit message, and</li><li>pointer to the commit that came directly before this commit.</li></ol><p>By pointer we mean a SHA-1 hash of the object; it is common to refer
to a commit by its hash.</p><p>Note: if any of the items above is changed, the commit hash will change too!</p><p><img alt="a commit" src="/assets/images/commit-5c817282f2f1511b2e0070419a961148.svg"></p><p>Unfortunately, the verb &quot;commit&quot;  and the noun &quot;commit&quot; are the spelled the
same way in English; when we use it as a verb, we mean the act of perfoming a
commit operation, whereas the noun refers to the commit object (or its hash).</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="how-a-sequence-of-commits-form-a-graph"></a>How a sequence of commits form a graph<a aria-hidden="true" tabindex="-1" class="hash-link" href="#how-a-sequence-of-commits-form-a-graph" title="Direct link to heading">#</a></h2><p>Because a commit stores a reference to the preceding commit, in other other
words, because a commit has a parent, the repository can be represented as a
directed acyclic graph: nodes are commits and a directed edge <code>(commit2, commit1)</code> indicates
that commit <code>commit1</code> is a parent of <code>commit2</code>.</p><p><img alt="three commits" src="/assets/images/three_commits-858c0080e18e134b2e4f5f27525107a2.svg"></p><p>For ease of representation, I&#x27;m using names for the commits in the pictures,
but <code>commit1</code> and <code>commit2</code> actually represent the hash of the respective
commits.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="branches-a-name-and-a-pointer"></a>Branches: a name and a pointer<a aria-hidden="true" tabindex="-1" class="hash-link" href="#branches-a-name-and-a-pointer" title="Direct link to heading">#</a></h2><p>The concept of a <em>branch</em> is what allows us to navigate through important states
of a repository. A branch in Git is a pair <code>(name, pointer to a commit)</code>.</p><p><img alt="three branches" src="/assets/images/three_branches-dc3714b060be01a86e46abf5dc09127d.svg"></p><p>In this example, we have two branches named <code>feature1</code> and <code>master</code>, both
pointing to commit <code>commit1</code>, and a branch named <code>feature2</code> pointing to
<code>commit2</code>.</p><p>Note: there is nothing special about the branch named <code>master</code>. When you create
a repository from scratch, you need a name for the starting branch -- <code>master</code>
is the default and few repositories bother renaming it.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="you-are-where-your-head-is"></a>You are where your HEAD is.<a aria-hidden="true" tabindex="-1" class="hash-link" href="#you-are-where-your-head-is" title="Direct link to heading">#</a></h2><p>Since we&#x27;re jumping around the history of the repository all the time, how do
we know which snapshot we&#x27;re looking at? This information is tracked by a
special pointer, called <code>HEAD</code>. Most of the time, <code>HEAD</code> points to a branch:</p><p><img alt="head introduction" src="/assets/images/head_intro-1b595d6e919931619c7b1db0d4792342.svg"></p><p>In this example, we are looking at the repository as defined by branch
<code>feature2</code>, which points to <code>commit2</code>.</p><p>When we add a new commit, we advance the branch pointed by the <code>HEAD</code>:</p><p><img alt="head advancing" src="/assets/images/head_advanced-1455b15f9af0f535d3944df952741ad8.svg"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="a-word-on-detached-heads"></a>A word on detached <code>HEADS</code><a aria-hidden="true" tabindex="-1" class="hash-link" href="#a-word-on-detached-heads" title="Direct link to heading">#</a></h2><p>What if we want to inspect snapshots that are not pointed to by any
branch, like <code>commit2</code>? You can use its hash and force <code>HEAD</code> to point to it:</p><p><img alt="detached_head_state" src="/assets/images/detached_head_state-11acddcb77a1432f04989824269f0b36.svg"></p><p>You are now in what is called a <em>detached  <code>HEAD</code> state</em>, that is, <code>HEAD</code> is
not following any branches. This is not what you&#x27;ll be doing 99.99% of the
time and, once in a detached <code>HEAD</code> state, you&#x27;ll either create a new branch
pointing to the current snapshot, or switch to some other branch; both of those
actions restore your <code>HEAD</code> to its natural state: that of tracking branches.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="change-branches-often"></a>Change branches often...<a aria-hidden="true" tabindex="-1" class="hash-link" href="#change-branches-often" title="Direct link to heading">#</a></h2><p>Changing a branch is simple: just point your <code>HEAD</code> to it, and Git will
assemble the repository as it was in the commit pointed to by that branch.</p><p><img alt="changing heads" src="/assets/images/change_head-5d923c107fe4158dcfcd7762337dc6ef.svg"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="-except-when-you-cant"></a>... except when you can&#x27;t<a aria-hidden="true" tabindex="-1" class="hash-link" href="#-except-when-you-cant" title="Direct link to heading">#</a></h2><p>Changing branches is a natural operation that we perform often, but it has the
potential to overwrite non-committed changes.</p><p>For example, suppose you have edited <code>main.cpp</code> <strong>but not committed those
changes</strong> and suppose you attempt to change <code>HEAD</code> to <code>other_branch</code>.  However,
<code>main.cpp</code> is different in <code>other_branch</code>. What should happen to your
non-committed changes? Should Git discard them  and overwrite <code>main.cpp</code> with
the version in <code>other_branch</code>?</p><p>Git follows a principle that it will <strong>never</strong> allow you to lose changes by accident,
unless you are explicit about it by using dangerous keywords like &quot;force&quot; or
&quot;hard&quot;.</p><p>In the example above, unless Git can <em>cleanly</em> and <em>unambiguously</em> apply the
non-committed changes on top of the target branch, it will NOT let you change
branches. In particular, you should be able to move back and forth between two
branches without any loss of information; if that&#x27;s not possible, Git will not
let you change branches.</p><p>Merely staging the changes wouldn&#x27;t be enough either. In other words: commit,
commit, commit, commit. Don&#x27;t be afraid of committing, it is the most powerful
tool in your toolbox.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-graph-doesnt-have-to-be-linear"></a>The graph doesn&#x27;t have to be linear<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-graph-doesnt-have-to-be-linear" title="Direct link to heading">#</a></h2><p>So far, our graph has always been a &quot;straight line&quot;. However, what happens if
we add a new commit to <code>feature1</code> in the example shown previously? The graph
becomes more interesting:</p><p><img alt="non linear history" src="/assets/images/non_straight_line-e210935e5b6845249a120b4df64754c3.svg"></p><p>Note that, because our head was pointing to the <code>feature1</code> branch, the next
commit advanced that branch.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="deleting-a-branch-deletes-a-name"></a>Deleting a branch deletes a name.<a aria-hidden="true" tabindex="-1" class="hash-link" href="#deleting-a-branch-deletes-a-name" title="Direct link to heading">#</a></h2><p>Because a branch is just a pointer, deleting it is a quick operation: just
delete the pointer. However...</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="git-will-not-let-you-delete-some-branches"></a>Git will not let you delete some branches.<a aria-hidden="true" tabindex="-1" class="hash-link" href="#git-will-not-let-you-delete-some-branches" title="Direct link to heading">#</a></h3><p>What if deleting a branch would cause loss of information?</p><p>The canonical way to navigate between states of your repository is by
changing your HEAD so that it points to different branches, and that is done
through branch names; Git doesn&#x27;t expect you to memorize hashes.</p><p>Consider this example:</p><p><img alt="cant delete branch" src="/assets/images/cant_delete_branch-8824885b30b0e4af6f052706cee219f0.svg"></p><p>If we delete the branch <code>feature2</code>, the commits in red would be lost forever:
there is no branch that includes those commits, i.e. there is no way to put
your repository in a state containing those commits<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup>. The only way to
inspect those commits would be if you memorized their hashes and moved into a
detached head state.</p><p>As such, Git will not let you delete that branch unless you force it to.</p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="merging-branches"></a>Merging branches<a aria-hidden="true" tabindex="-1" class="hash-link" href="#merging-branches" title="Direct link to heading">#</a></h1><p>We&#x27;ve seen what branches are and how they relate to commits. The next building
block to be examined is how to merge work from one branch into another. There
are many different ways to accomplish this, and the choice depends on what
you want the final commit history to look like.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="easy-merging-fast-forward"></a>Easy merging: fast forward<a aria-hidden="true" tabindex="-1" class="hash-link" href="#easy-merging-fast-forward" title="Direct link to heading">#</a></h2><p>Let&#x27;s consider the scenario we had before:</p><p><img alt="ready to merge" src="/assets/images/ready_to_merge-78067d01ea363a32c511eb104923f74b.svg"></p><p>Suppose the work from the <code>feature1</code> branch has been tested and is ready to be
merged back into <code>master</code>. To emphasize: we want to merge <code>feature1</code> into
<code>master</code>, not the other way around (more on this later). </p><p>Well, lucky you, nobody has committed into master since the work on <code>feature1</code>
started! Because <strong>all commits in <code>master</code> are also in <code>feature1</code></strong>, Git can
simply move the <code>master</code> pointer forward, a method known as a <em>fast forward</em>:</p><p><img alt="afer merge" src="/assets/images/after_merge-3a157cae3dcc6657a28ddc4fec004ab6.svg"></p><p>This method is always free of conflicts, that is, it will never require manual
intervention to resolve edits made in the same file on the two branches being
merged.</p><p>The <code>feature1</code> branch is now irrelevant and can be deleted:</p><p><img alt="afer merge branch deleted" src="/assets/images/after_merge_branch_deleted-a84cdcb96633474dea02d6dae5e63215.svg"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="non-trivial-merges"></a>Non-trivial merges<a aria-hidden="true" tabindex="-1" class="hash-link" href="#non-trivial-merges" title="Direct link to heading">#</a></h2><p>When many developers are working on the same repository, chances are Git won&#x27;t
always be able to fast-forward. Suppose the <code>feature2</code> branch from above is
ready to be merged back into master, what will happen?</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="three-way-merge"></a>Three-way merge!<a aria-hidden="true" tabindex="-1" class="hash-link" href="#three-way-merge" title="Direct link to heading">#</a></h3><p>When fast forwards are not possible, Git will identify three commits to help it
perform the merge:</p><ol><li>The commit pointed to by the destination branch.</li><li>The commit pointed to by the source branch.</li><li>The commit that is the lowest common ancestor of 1 and 2.</li></ol><p>Using our previous example, the commits are as follows:</p><p><img alt="merge_commit_points" src="/assets/images/merge_commit_points-5128382ba2be3a94949ba402cee9f694.svg"></p><p>Using those commits, Git will now merge the two branches, identify conflicting
changes and create a new commit representing the merge:</p><p><img alt="merge_commit" src="/assets/images/merge_commit-375e360bf35907aa7c421edd01d8d148.svg"></p><p>If any conflicting changes are found, Git will ask you to resolve them before
the merge commit is created.</p><p>The <code>feature2</code> branch can now be deleted.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="rebase"></a>Rebase!<a aria-hidden="true" tabindex="-1" class="hash-link" href="#rebase" title="Direct link to heading">#</a></h3><p>A lot of projects frown upon complicated graphs for their main development
branches, as such, they forbid three-way merges. To maintain a clean and linear
history, a different procedure is needed.</p><p>Let&#x27;s pretend we never did the three-way merge with <code>feature2</code>:</p><p><img alt="before rebase" src="/assets/images/before_rebase-63a8fb87e2ad93af7e2be68c6b069fd9.svg"></p><p>Instead of a three-way merge, we can re-apply commits from <code>feature2</code> on top of
<code>master</code>, this is known as a rebase of <code>feature2</code> on top of <code>master</code>.</p><ol><li><p>Start with our <code>HEAD</code> on the source branch (<code>feature2</code>).</p></li><li><p>Git rewinds <code>HEAD</code> to the lowest common ancestor of the two branches.</p></li><li><p>Git forwards <code>HEAD</code> along the path of the target branch (<code>master</code>).</p><p><img alt="mid_rebase" src="/assets/images/mid_rebase-43318f91160a5456b80856c0cc07642a.svg"></p></li><li><p>Git replays the commits of <code>feature2</code>.</p><p><img alt="rebase_finished" src="/assets/images/rebase_finished-0854db9c182ccf9949981dc4062a6e68.svg"></p></li></ol><p>If any commits can&#x27;t be applied cleanly, Git asks for your intervention before continuing.</p><p>Note: the new commits are different from the original ones and they will have
different hashes. Why?<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup></p><p>Now, if you switch HEAD to <code>master</code> and try to merge with <code>feature2</code>, a simple
fast forward will do!</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="keeping-feature-branches-up-to-date-with-the-main-branch"></a>Keeping feature branches up-to-date with the main branch<a aria-hidden="true" tabindex="-1" class="hash-link" href="#keeping-feature-branches-up-to-date-with-the-main-branch" title="Direct link to heading">#</a></h3><p>When developing a big feature in a separate branch, it&#x27;s wise to ensure our
code is up-to-date with the main branch of the project, otherwise we run the
risk of working on top of a stale version of the code base.</p><p>One way to accomplish this is by frequently merging the main branch into the
feature branch:</p><p><img alt="frequent_merges" src="/assets/images/frequent_merges-b693273cc9df2555cafacd03c723e64c.svg"></p><p>If your project disallows three way merges, you would frequently
rebase the feature branch on top of the main branch:</p><p><img alt="frequent_rebases" src="/assets/images/frequent_rebases-2671d59474834f7dcc8e570a250bb164.svg"></p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="distributed-git"></a>Distributed Git<a aria-hidden="true" tabindex="-1" class="hash-link" href="#distributed-git" title="Direct link to heading">#</a></h1><p>So far, everything we&#x27;ve covered assumes the entirety of development is
performed locally, that is, there are no copies of the repository outside our
machine. There are no pesky coworkers, no remote servers, nothing!</p><p>However, that&#x27;s not how modern development is done. So how does Git handle
multiple developers?</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="remotes"></a>Remotes<a aria-hidden="true" tabindex="-1" class="hash-link" href="#remotes" title="Direct link to heading">#</a></h2><p>A <em>remote</em> is just another copy of the same repository located elsewhere.
Git needs to know where and how to find it through an address and protocol:
ssh, https, file system path, etc.</p><p>Suppose Alice and Bob both have a copy of the same repository in their own
machines:</p><p><img alt="alice_and_bob" src="/assets/images/alice_and_bob-24d47c4b7465a882efa4a3a2301d211f.svg"></p><p>Now suppose Alice and Bob want to collaborate, thus they need the ability to
see what each other is up to. Alice will add a <em>remote</em> called <code>remote_bob</code> and
Bob will add a <em>remote</em> called <code>remote_alice</code>.</p><p><img alt="alice_and_bob_with_remotes" src="/assets/images/alice_and_bob_with_remotes-d4c0f9cad880c1cb3d18ee7a58fca396.svg"></p><p>Both will then <em>fetch</em> updates from their remotes, resulting in the following
trees:</p><p><img alt="alice_and_bob_after_fetch" src="/assets/images/alice_and_bob_after_fetch-a00eb185e41cdea9749635c6943e2f59.svg"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="agreement-on-distributed-systems-is-a-hard-problem"></a>Agreement on distributed systems is a hard problem<a aria-hidden="true" tabindex="-1" class="hash-link" href="#agreement-on-distributed-systems-is-a-hard-problem" title="Direct link to heading">#</a></h2><p>Because the copies are independent of each other, branches may evolve differently
in each remote. For instance, Alice and Bob might make different, independent commits
in their master branches:</p><p><img alt="masters_diverged" src="/assets/images/masters_diverged-76f18943cd5edec13acc21c8d0ce88c4.svg"></p><p>Which version of master should be accepted as correct? The situation can get a
lot worse if you have many developers working at the same time. How are all
these developers supposed to agree on what the correct version of a branch
should be?</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="follow-an-origin"></a>Follow an origin<a aria-hidden="true" tabindex="-1" class="hash-link" href="#follow-an-origin" title="Direct link to heading">#</a></h2><p>The typical way to solve this problem is by electing a <em>remote</em> to be the
correct copy of the repository, and letting developers try to influence it.
Usually, this remote is called <code>origin</code>.</p><p>Consider the situation we had before, where Alice and Bob had diverged on what
master should look like. Instead of interacting with each other&#x27;s repository
directly, they only interact with <code>origin</code>:</p><p><img alt="enter_the_origin" src="/assets/images/enter_the_origin-fe53c8238eeb466d8cad237b509e7799.svg"></p><p>(I&#x27;m omitting <code>HEAD</code> here to keep the diagram manageable.)</p><p>To publish their own versions of <code>master</code> to <code>origin/master</code>, Alice and Bob will
attempt to perform a <em>push</em> operation into their <code>origin</code> remote. Let&#x27;s assume
that Alice performs her <em>push</em> first, resulting in the following scenario:</p><p><img alt="alice_won" src="/assets/images/alice_won-4de42531044ec04154296e63164a7ab6.svg"></p><p>Notice how Bob doesn&#x27;t yet know that <code>origin</code> has accepted Alice&#x27;s update to
master. When Bob tries to push his <code>master</code> into <code>origin/master</code>, Git will tell
him: &quot;I can&#x27;t do this, because your <code>origin/master</code> is not what <code>origin</code> says
it should be. Do a <em>fetch</em> first!&quot;</p><p>Once Bob fetches <code>origin</code>, this is what he sees:</p><p><img alt="bob_fetches" src="/assets/images/bob_fetches-f285439d94f5684c3f5e54e6b2f00499.svg"></p><p>Then Bob can either rebase <code>master</code> on top of <code>origin/master</code> or merge
<code>origin/master</code> into <code>master</code>. Now Bob is ready to <em>push</em> <code>master</code> to
<code>origin/master</code>.</p><p>Here&#x27;s what the final result would look like if Bob had used the merge option:</p><p><img alt="bob_pushes" src="/assets/images/bob_pushes-b49af58ce5138e5cb658769c6d8f3dc9.svg"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="origin-with-some-interface"></a>Origin with some interface<a aria-hidden="true" tabindex="-1" class="hash-link" href="#origin-with-some-interface" title="Direct link to heading">#</a></h2><p>In the previous example, <code>origin</code> could only be changed by trying to <code>push</code>
updates to it. However, all pushes are rejected unless we have
the exactly same view of the branch being pushed to as <code>origin</code> does.</p><p>To fix this problem, it might be desirable to have <code>origin</code> itself run commands
on its copy of the repository and let downstream users -- like Alice and Bob --
get updates by fetching; this is what services that host a repository typically
provide.</p><p>For instance, Alice might create a new branch, do some work, commit, and push
this new branch to <code>origin</code>. This push will always work without issues, because
she&#x27;s the only one working on it (barring any unlucky events where Bob created
a branch with the same name)</p><p><img alt="alice_origin_feature" src="/assets/images/alice_origin_feature-66c19447bc2e9ea30ff9f9655ca45c0d.svg"></p><p>Alice can then go into the interface provided by <code>origin</code> - likely a webpage -
click a &quot;create merge request&quot; button, specifying <code>feature_alice</code> as the source
branch and <code>master</code> as the destination branch.  This will have the effect
of <code>origin</code> performing the merge on its side.</p><p><img alt="alice_origin_feature_merged" src="/assets/images/alice_origin_feature_merged-07bcb7a42b5ceaa6ede35d8431fa9a52.svg"></p><p>Note that Alice will not see the merge on her copy of the repository until she
performs a fetch.</p><p>If the merge can&#x27;t be performed due to conflicts, the interface will let Alice
know.</p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="conclusion"></a>Conclusion<a aria-hidden="true" tabindex="-1" class="hash-link" href="#conclusion" title="Direct link to heading">#</a></h1><p>With the mental model clear, you&#x27;ll have a much easier time with the command
line interface, as the terminology used in this article reflects what Git uses
for its commands and its manual. The next step is to start over, and match
each operation we discussed to its equivalent command. I&#x27;ve linked some
resources for further reading below.</p><p>Feel free to send me a message on Twitter if you feel like something isn&#x27;t clear!</p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="further-reading"></a>Further reading<a aria-hidden="true" tabindex="-1" class="hash-link" href="#further-reading" title="Direct link to heading">#</a></h1><ul><li><p>Git has its own book called <a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener noreferrer">Pro Git</a> and it&#x27;s free! It is by far the best
resource I found while learning.</p></li><li><p>If you&#x27;re wondering how to use branches to effectively manage a project, I
recommend reading the following articles: <a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener noreferrer">A successful Git branching model</a>
and the <a href="https://guides.github.com/introduction/flow/" target="_blank" rel="noopener noreferrer">Github guide</a>.</p></li></ul><div class="footnotes"><hr><ol><li id="fn-1">In fact, Git would permanently delete all contents
associated with those commits next time it tries to cleanup its internal data
structures.<a href="#fnref-1" class="footnote-backref">â†©</a></li><li id="fn-2">The new commits have different
parent commits, and if you had to solve any conflicts during the rebase, each
intermediate snapshot will be different.<a href="#fnref-2" class="footnote-backref">â†©</a></li></ol></div></div></article><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« About me</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/20200306-static_var/README"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Static variables, static storage, static initialization, constant initialization, constinit, constexpr Â»</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_3SO_"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#staging" class="table-of-contents__link">Staging</a></li><li><a href="#commit-definition" class="table-of-contents__link">Commit definition</a></li><li><a href="#how-a-sequence-of-commits-form-a-graph" class="table-of-contents__link">How a sequence of commits form a graph</a></li><li><a href="#branches-a-name-and-a-pointer" class="table-of-contents__link">Branches: a name and a pointer</a></li><li><a href="#you-are-where-your-head-is" class="table-of-contents__link">You are where your HEAD is.</a></li><li><a href="#a-word-on-detached-heads" class="table-of-contents__link">A word on detached <code>HEADS</code></a></li><li><a href="#change-branches-often" class="table-of-contents__link">Change branches often...</a></li><li><a href="#-except-when-you-cant" class="table-of-contents__link">... except when you can&#39;t</a></li><li><a href="#the-graph-doesnt-have-to-be-linear" class="table-of-contents__link">The graph doesn&#39;t have to be linear</a></li><li><a href="#deleting-a-branch-deletes-a-name" class="table-of-contents__link">Deleting a branch deletes a name.</a><ul><li><a href="#git-will-not-let-you-delete-some-branches" class="table-of-contents__link">Git will not let you delete some branches.</a></li></ul></li><li><a href="#easy-merging-fast-forward" class="table-of-contents__link">Easy merging: fast forward</a></li><li><a href="#non-trivial-merges" class="table-of-contents__link">Non-trivial merges</a><ul><li><a href="#three-way-merge" class="table-of-contents__link">Three-way merge!</a></li><li><a href="#rebase" class="table-of-contents__link">Rebase!</a></li><li><a href="#keeping-feature-branches-up-to-date-with-the-main-branch" class="table-of-contents__link">Keeping feature branches up-to-date with the main branch</a></li></ul></li><li><a href="#remotes" class="table-of-contents__link">Remotes</a></li><li><a href="#agreement-on-distributed-systems-is-a-hard-problem" class="table-of-contents__link">Agreement on distributed systems is a hard problem</a></li><li><a href="#follow-an-origin" class="table-of-contents__link">Follow an origin</a></li><li><a href="#origin-with-some-interface" class="table-of-contents__link">Origin with some interface</a></li></ul></div></div></div></div></main></div></div></div>
<script src="/styles.9959f271.js"></script>
<script src="/runtime~main.5df455bb.js"></script>
<script src="/main.01c6edad.js"></script>
<script src="/1.43c5d01a.js"></script>
<script src="/2.cf4e590e.js"></script>
<script src="/13.c5726d0f.js"></script>
<script src="/935f2afb.584f3aef.js"></script>
<script src="/17896441.2afc73b6.js"></script>
<script src="/8dded891.700a24dc.js"></script>
</body>
</html>